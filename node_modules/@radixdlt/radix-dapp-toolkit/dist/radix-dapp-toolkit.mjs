var Ut = function(t, e) {
  return Ut = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, Ut(t, e);
};
function De(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Ut(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
function hi(t, e, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(s) {
      s(o);
    });
  }
  return new (n || (n = Promise))(function(o, s) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (p) {
        s(p);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (p) {
        s(p);
      }
    }
    function u(l) {
      l.done ? o(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function Xn(t, e) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; s && (s = 0, u[0] && (n = 0)), n; )
      try {
        if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < o[1]) {
              n.label = o[1], o = u;
              break;
            }
            if (o && n.label < o[2]) {
              n.label = o[2], n.ops.push(u);
              break;
            }
            o[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], i = 0;
      } finally {
        r = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Ke(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function fe(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), i, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
      o.push(i.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}
function _e(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, o; r < i; r++)
      (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}
function Fe(t) {
  return this instanceof Fe ? (this.v = t, this) : new Fe(t);
}
function pi(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), i, o = [];
  return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(f) {
    r[f] && (i[f] = function(h) {
      return new Promise(function(g, d) {
        o.push([f, h, g, d]) > 1 || a(f, h);
      });
    });
  }
  function a(f, h) {
    try {
      c(r[f](h));
    } catch (g) {
      p(o[0][3], g);
    }
  }
  function c(f) {
    f.value instanceof Fe ? Promise.resolve(f.value.v).then(u, l) : p(o[0][2], f);
  }
  function u(f) {
    a("next", f);
  }
  function l(f) {
    a("throw", f);
  }
  function p(f, h) {
    f(h), o.shift(), o.length && a(o[0][0], o[0][1]);
  }
}
function mi(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Ke == "function" ? Ke(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(o) {
    n[o] = t[o] && function(s) {
      return new Promise(function(a, c) {
        s = t[o](s), i(a, c, s.done, s.value);
      });
    };
  }
  function i(o, s, a, c) {
    Promise.resolve(c).then(function(u) {
      o({ value: u, done: a });
    }, s);
  }
}
function C(t) {
  return typeof t == "function";
}
function nn(t) {
  var e = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = t(e);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var At = nn(function(t) {
  return function(n) {
    t(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, i) {
      return i + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function Wt(t, e) {
  if (t) {
    var n = t.indexOf(e);
    0 <= n && t.splice(n, 1);
  }
}
var Te = function() {
  function t(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var e, n, r, i, o;
    if (!this.closed) {
      this.closed = !0;
      var s = this._parentage;
      if (s)
        if (this._parentage = null, Array.isArray(s))
          try {
            for (var a = Ke(s), c = a.next(); !c.done; c = a.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (d) {
            e = { error: d };
          } finally {
            try {
              c && !c.done && (n = a.return) && n.call(a);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          s.remove(this);
      var l = this.initialTeardown;
      if (C(l))
        try {
          l();
        } catch (d) {
          o = d instanceof At ? d.errors : [d];
        }
      var p = this._finalizers;
      if (p) {
        this._finalizers = null;
        try {
          for (var f = Ke(p), h = f.next(); !h.done; h = f.next()) {
            var g = h.value;
            try {
              yn(g);
            } catch (d) {
              o = o ?? [], d instanceof At ? o = _e(_e([], fe(o)), fe(d.errors)) : o.push(d);
            }
          }
        } catch (d) {
          r = { error: d };
        } finally {
          try {
            h && !h.done && (i = f.return) && i.call(f);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (o)
        throw new At(o);
    }
  }, t.prototype.add = function(e) {
    var n;
    if (e && e !== this)
      if (this.closed)
        yn(e);
      else {
        if (e instanceof t) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e);
      }
  }, t.prototype._hasParent = function(e) {
    var n = this._parentage;
    return n === e || Array.isArray(n) && n.includes(e);
  }, t.prototype._addParent = function(e) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e;
  }, t.prototype._removeParent = function(e) {
    var n = this._parentage;
    n === e ? this._parentage = null : Array.isArray(n) && Wt(n, e);
  }, t.prototype.remove = function(e) {
    var n = this._finalizers;
    n && Wt(n, e), e instanceof t && e._removeParent(this);
  }, t.EMPTY = function() {
    var e = new t();
    return e.closed = !0, e;
  }(), t;
}(), er = Te.EMPTY;
function tr(t) {
  return t instanceof Te || t && "closed" in t && C(t.remove) && C(t.add) && C(t.unsubscribe);
}
function yn(t) {
  C(t) ? t() : t.unsubscribe();
}
var rn = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, Mt = {
  setTimeout: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var i = Mt.delegate;
    return i != null && i.setTimeout ? i.setTimeout.apply(i, _e([t, e], fe(n))) : setTimeout.apply(void 0, _e([t, e], fe(n)));
  },
  clearTimeout: function(t) {
    var e = Mt.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(t);
  },
  delegate: void 0
};
function nr(t) {
  Mt.setTimeout(function() {
    throw t;
  });
}
function Ft() {
}
var ft = null;
function mt(t) {
  if (rn.useDeprecatedSynchronousErrorHandling) {
    var e = !ft;
    if (e && (ft = { errorThrown: !1, error: null }), t(), e) {
      var n = ft, r = n.errorThrown, i = n.error;
      if (ft = null, r)
        throw i;
    }
  } else
    t();
}
var on = function(t) {
  De(e, t);
  function e(n) {
    var r = t.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, tr(n) && n.add(r)) : r.destination = gi, r;
  }
  return e.create = function(n, r, i) {
    return new Ve(n, r, i);
  }, e.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, e.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(n) {
    this.destination.next(n);
  }, e.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(Te), vi = Function.prototype.bind;
function kt(t, e) {
  return vi.call(t, e);
}
var yi = function() {
  function t(e) {
    this.partialObserver = e;
  }
  return t.prototype.next = function(e) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(e);
      } catch (r) {
        dt(r);
      }
  }, t.prototype.error = function(e) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(e);
      } catch (r) {
        dt(r);
      }
    else
      dt(e);
  }, t.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (n) {
        dt(n);
      }
  }, t;
}(), Ve = function(t) {
  De(e, t);
  function e(n, r, i) {
    var o = t.call(this) || this, s;
    if (C(n) || !n)
      s = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: i ?? void 0
      };
    else {
      var a;
      o && rn.useDeprecatedNextContext ? (a = Object.create(n), a.unsubscribe = function() {
        return o.unsubscribe();
      }, s = {
        next: n.next && kt(n.next, a),
        error: n.error && kt(n.error, a),
        complete: n.complete && kt(n.complete, a)
      }) : s = n;
    }
    return o.destination = new yi(s), o;
  }
  return e;
}(on);
function dt(t) {
  nr(t);
}
function bi(t) {
  throw t;
}
var gi = {
  closed: !0,
  next: Ft,
  error: bi,
  complete: Ft
}, sn = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function lt(t) {
  return t;
}
function wi(t) {
  return t.length === 0 ? lt : t.length === 1 ? t[0] : function(n) {
    return t.reduce(function(r, i) {
      return i(r);
    }, n);
  };
}
var F = function() {
  function t(e) {
    e && (this._subscribe = e);
  }
  return t.prototype.lift = function(e) {
    var n = new t();
    return n.source = this, n.operator = e, n;
  }, t.prototype.subscribe = function(e, n, r) {
    var i = this, o = xi(e) ? e : new Ve(e, n, r);
    return mt(function() {
      var s = i, a = s.operator, c = s.source;
      o.add(a ? a.call(o, c) : c ? i._subscribe(o) : i._trySubscribe(o));
    }), o;
  }, t.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (n) {
      e.error(n);
    }
  }, t.prototype.forEach = function(e, n) {
    var r = this;
    return n = bn(n), new n(function(i, o) {
      var s = new Ve({
        next: function(a) {
          try {
            e(a);
          } catch (c) {
            o(c), s.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
      r.subscribe(s);
    });
  }, t.prototype._subscribe = function(e) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e);
  }, t.prototype[sn] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var e = [], n = 0; n < arguments.length; n++)
      e[n] = arguments[n];
    return wi(e)(this);
  }, t.prototype.toPromise = function(e) {
    var n = this;
    return e = bn(e), new e(function(r, i) {
      var o;
      n.subscribe(function(s) {
        return o = s;
      }, function(s) {
        return i(s);
      }, function() {
        return r(o);
      });
    });
  }, t.create = function(e) {
    return new t(e);
  }, t;
}();
function bn(t) {
  var e;
  return (e = t ?? rn.Promise) !== null && e !== void 0 ? e : Promise;
}
function _i(t) {
  return t && C(t.next) && C(t.error) && C(t.complete);
}
function xi(t) {
  return t && t instanceof on || _i(t) && tr(t);
}
function Si(t) {
  return C(t == null ? void 0 : t.lift);
}
function G(t) {
  return function(e) {
    if (Si(e))
      return e.lift(function(n) {
        try {
          return t(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function V(t, e, n, r, i) {
  return new Ti(t, e, n, r, i);
}
var Ti = function(t) {
  De(e, t);
  function e(n, r, i, o, s, a) {
    var c = t.call(this, n) || this;
    return c.onFinalize = s, c.shouldUnsubscribe = a, c._next = r ? function(u) {
      try {
        r(u);
      } catch (l) {
        n.error(l);
      }
    } : t.prototype._next, c._error = o ? function(u) {
      try {
        o(u);
      } catch (l) {
        n.error(l);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._error, c._complete = i ? function() {
      try {
        i();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      t.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, e;
}(on), Oi = nn(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), ue = function(t) {
  De(e, t);
  function e() {
    var n = t.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return e.prototype.lift = function(n) {
    var r = new gn(this, this);
    return r.operator = n, r;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new Oi();
  }, e.prototype.next = function(n) {
    var r = this;
    mt(function() {
      var i, o;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var s = Ke(r.currentObservers), a = s.next(); !a.done; a = s.next()) {
            var c = a.value;
            c.next(n);
          }
        } catch (u) {
          i = { error: u };
        } finally {
          try {
            a && !a.done && (o = s.return) && o.call(s);
          } finally {
            if (i)
              throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(n) {
    var r = this;
    mt(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var i = r.observers; i.length; )
          i.shift().error(n);
      }
    });
  }, e.prototype.complete = function() {
    var n = this;
    mt(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, n);
  }, e.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, e.prototype._innerSubscribe = function(n) {
    var r = this, i = this, o = i.hasError, s = i.isStopped, a = i.observers;
    return o || s ? er : (this.currentObservers = null, a.push(n), new Te(function() {
      r.currentObservers = null, Wt(a, n);
    }));
  }, e.prototype._checkFinalizedStatuses = function(n) {
    var r = this, i = r.hasError, o = r.thrownError, s = r.isStopped;
    i ? n.error(o) : s && n.complete();
  }, e.prototype.asObservable = function() {
    var n = new F();
    return n.source = this, n;
  }, e.create = function(n, r) {
    return new gn(n, r);
  }, e;
}(F), gn = function(t) {
  De(e, t);
  function e(n, r) {
    var i = t.call(this) || this;
    return i.destination = n, i.source = r, i;
  }
  return e.prototype.next = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, n);
  }, e.prototype.error = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, n);
  }, e.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, e.prototype._subscribe = function(n) {
    var r, i;
    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && i !== void 0 ? i : er;
  }, e;
}(ue), me = function(t) {
  De(e, t);
  function e(n) {
    var r = t.call(this) || this;
    return r._value = n, r;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(n) {
    var r = t.prototype._subscribe.call(this, n);
    return !r.closed && n.next(this._value), r;
  }, e.prototype.getValue = function() {
    var n = this, r = n.hasError, i = n.thrownError, o = n._value;
    if (r)
      throw i;
    return this._throwIfClosed(), o;
  }, e.prototype.next = function(n) {
    t.prototype.next.call(this, this._value = n);
  }, e;
}(ue), rr = {
  now: function() {
    return (rr.delegate || Date).now();
  },
  delegate: void 0
}, Ie = function(t) {
  De(e, t);
  function e(n, r, i) {
    n === void 0 && (n = 1 / 0), r === void 0 && (r = 1 / 0), i === void 0 && (i = rr);
    var o = t.call(this) || this;
    return o._bufferSize = n, o._windowTime = r, o._timestampProvider = i, o._buffer = [], o._infiniteTimeWindow = !0, o._infiniteTimeWindow = r === 1 / 0, o._bufferSize = Math.max(1, n), o._windowTime = Math.max(1, r), o;
  }
  return e.prototype.next = function(n) {
    var r = this, i = r.isStopped, o = r._buffer, s = r._infiniteTimeWindow, a = r._timestampProvider, c = r._windowTime;
    i || (o.push(n), !s && o.push(a.now() + c)), this._trimBuffer(), t.prototype.next.call(this, n);
  }, e.prototype._subscribe = function(n) {
    this._throwIfClosed(), this._trimBuffer();
    for (var r = this._innerSubscribe(n), i = this, o = i._infiniteTimeWindow, s = i._buffer, a = s.slice(), c = 0; c < a.length && !n.closed; c += o ? 1 : 2)
      n.next(a[c]);
    return this._checkFinalizedStatuses(n), r;
  }, e.prototype._trimBuffer = function() {
    var n = this, r = n._bufferSize, i = n._timestampProvider, o = n._buffer, s = n._infiniteTimeWindow, a = (s ? 1 : 2) * r;
    if (r < 1 / 0 && a < o.length && o.splice(0, o.length - a), !s) {
      for (var c = i.now(), u = 0, l = 1; l < o.length && o[l] <= c; l += 2)
        u = l;
      u && o.splice(0, u + 1);
    }
  }, e;
}(ue), Ei = new F(function(t) {
  return t.complete();
});
function Ai(t) {
  return t && C(t.schedule);
}
function an(t) {
  return t[t.length - 1];
}
function ki(t) {
  return C(an(t)) ? t.pop() : void 0;
}
function ir(t) {
  return Ai(an(t)) ? t.pop() : void 0;
}
function Ii(t, e) {
  return typeof an(t) == "number" ? t.pop() : e;
}
var un = function(t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
function or(t) {
  return C(t == null ? void 0 : t.then);
}
function sr(t) {
  return C(t[sn]);
}
function ar(t) {
  return Symbol.asyncIterator && C(t == null ? void 0 : t[Symbol.asyncIterator]);
}
function ur(t) {
  return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Pi() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var cr = Pi();
function lr(t) {
  return C(t == null ? void 0 : t[cr]);
}
function fr(t) {
  return pi(this, arguments, function() {
    var n, r, i, o;
    return Xn(this, function(s) {
      switch (s.label) {
        case 0:
          n = t.getReader(), s.label = 1;
        case 1:
          s.trys.push([1, , 9, 10]), s.label = 2;
        case 2:
          return [4, Fe(n.read())];
        case 3:
          return r = s.sent(), i = r.value, o = r.done, o ? [4, Fe(void 0)] : [3, 5];
        case 4:
          return [2, s.sent()];
        case 5:
          return [4, Fe(i)];
        case 6:
          return [4, s.sent()];
        case 7:
          return s.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function dr(t) {
  return C(t == null ? void 0 : t.getReader);
}
function Q(t) {
  if (t instanceof F)
    return t;
  if (t != null) {
    if (sr(t))
      return Ci(t);
    if (un(t))
      return Ri(t);
    if (or(t))
      return $i(t);
    if (ar(t))
      return hr(t);
    if (lr(t))
      return ji(t);
    if (dr(t))
      return Ni(t);
  }
  throw ur(t);
}
function Ci(t) {
  return new F(function(e) {
    var n = t[sn]();
    if (C(n.subscribe))
      return n.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function Ri(t) {
  return new F(function(e) {
    for (var n = 0; n < t.length && !e.closed; n++)
      e.next(t[n]);
    e.complete();
  });
}
function $i(t) {
  return new F(function(e) {
    t.then(function(n) {
      e.closed || (e.next(n), e.complete());
    }, function(n) {
      return e.error(n);
    }).then(null, nr);
  });
}
function ji(t) {
  return new F(function(e) {
    var n, r;
    try {
      for (var i = Ke(t), o = i.next(); !o.done; o = i.next()) {
        var s = o.value;
        if (e.next(s), e.closed)
          return;
      }
    } catch (a) {
      n = { error: a };
    } finally {
      try {
        o && !o.done && (r = i.return) && r.call(i);
      } finally {
        if (n)
          throw n.error;
      }
    }
    e.complete();
  });
}
function hr(t) {
  return new F(function(e) {
    Li(t, e).catch(function(n) {
      return e.error(n);
    });
  });
}
function Ni(t) {
  return hr(fr(t));
}
function Li(t, e) {
  var n, r, i, o;
  return hi(this, void 0, void 0, function() {
    var s, a;
    return Xn(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = mi(t), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (s = r.value, e.next(s), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return a = c.sent(), i = { error: a }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (o = n.return) ? [4, o.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i)
            throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function ge(t, e, n, r, i) {
  r === void 0 && (r = 0), i === void 0 && (i = !1);
  var o = e.schedule(function() {
    n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (t.add(o), !i)
    return o;
}
function pr(t, e) {
  return e === void 0 && (e = 0), G(function(n, r) {
    n.subscribe(V(r, function(i) {
      return ge(r, t, function() {
        return r.next(i);
      }, e);
    }, function() {
      return ge(r, t, function() {
        return r.complete();
      }, e);
    }, function(i) {
      return ge(r, t, function() {
        return r.error(i);
      }, e);
    }));
  });
}
function mr(t, e) {
  return e === void 0 && (e = 0), G(function(n, r) {
    r.add(t.schedule(function() {
      return n.subscribe(r);
    }, e));
  });
}
function Zi(t, e) {
  return Q(t).pipe(mr(e), pr(e));
}
function Di(t, e) {
  return Q(t).pipe(mr(e), pr(e));
}
function qi(t, e) {
  return new F(function(n) {
    var r = 0;
    return e.schedule(function() {
      r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule());
    });
  });
}
function Ui(t, e) {
  return new F(function(n) {
    var r;
    return ge(n, e, function() {
      r = t[cr](), ge(n, e, function() {
        var i, o, s;
        try {
          i = r.next(), o = i.value, s = i.done;
        } catch (a) {
          n.error(a);
          return;
        }
        s ? n.complete() : n.next(o);
      }, 0, !0);
    }), function() {
      return C(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function vr(t, e) {
  if (!t)
    throw new Error("Iterable cannot be null");
  return new F(function(n) {
    ge(n, e, function() {
      var r = t[Symbol.asyncIterator]();
      ge(n, e, function() {
        r.next().then(function(i) {
          i.done ? n.complete() : n.next(i.value);
        });
      }, 0, !0);
    });
  });
}
function Wi(t, e) {
  return vr(fr(t), e);
}
function Mi(t, e) {
  if (t != null) {
    if (sr(t))
      return Zi(t, e);
    if (un(t))
      return qi(t, e);
    if (or(t))
      return Di(t, e);
    if (ar(t))
      return vr(t, e);
    if (lr(t))
      return Ui(t, e);
    if (dr(t))
      return Wi(t, e);
  }
  throw ur(t);
}
function yr(t, e) {
  return e ? Mi(t, e) : Q(t);
}
function Fi() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = ir(t);
  return yr(t, n);
}
var Bi = nn(function(t) {
  return function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function zi(t, e) {
  var n = typeof e == "object";
  return new Promise(function(r, i) {
    var o = new Ve({
      next: function(s) {
        r(s), o.unsubscribe();
      },
      error: i,
      complete: function() {
        n ? r(e.defaultValue) : i(new Bi());
      }
    });
    t.subscribe(o);
  });
}
function be(t, e) {
  return G(function(n, r) {
    var i = 0;
    n.subscribe(V(r, function(o) {
      r.next(t.call(e, o, i++));
    }));
  });
}
var Ki = Array.isArray;
function Vi(t, e) {
  return Ki(e) ? t.apply(void 0, _e([], fe(e))) : t(e);
}
function Hi(t) {
  return be(function(e) {
    return Vi(t, e);
  });
}
function Yi(t, e, n, r, i, o, s, a) {
  var c = [], u = 0, l = 0, p = !1, f = function() {
    p && !c.length && !u && e.complete();
  }, h = function(d) {
    return u < r ? g(d) : c.push(d);
  }, g = function(d) {
    o && e.next(d), u++;
    var _ = !1;
    Q(n(d, l++)).subscribe(V(e, function(x) {
      i == null || i(x), o ? h(x) : e.next(x);
    }, function() {
      _ = !0;
    }, void 0, function() {
      if (_)
        try {
          u--;
          for (var x = function() {
            var m = c.shift();
            s ? ge(e, s, function() {
              return g(m);
            }) : g(m);
          }; c.length && u < r; )
            x();
          f();
        } catch (m) {
          e.error(m);
        }
    }));
  };
  return t.subscribe(V(e, h, function() {
    p = !0, f();
  })), function() {
    a == null || a();
  };
}
function He(t, e, n) {
  return n === void 0 && (n = 1 / 0), C(e) ? He(function(r, i) {
    return be(function(o, s) {
      return e(r, o, i, s);
    })(Q(t(r, i)));
  }, n) : (typeof e == "number" && (n = e), G(function(r, i) {
    return Yi(r, i, t, n);
  }));
}
function Ji(t) {
  return t === void 0 && (t = 1 / 0), He(lt, t);
}
var Gi = ["addListener", "removeListener"], Qi = ["addEventListener", "removeEventListener"], Xi = ["on", "off"];
function Pe(t, e, n, r) {
  if (C(n) && (r = n, n = void 0), r)
    return Pe(t, e, n).pipe(Hi(r));
  var i = fe(no(t) ? Qi.map(function(a) {
    return function(c) {
      return t[a](e, c, n);
    };
  }) : eo(t) ? Gi.map(wn(t, e)) : to(t) ? Xi.map(wn(t, e)) : [], 2), o = i[0], s = i[1];
  if (!o && un(t))
    return He(function(a) {
      return Pe(a, e, n);
    })(Q(t));
  if (!o)
    throw new TypeError("Invalid event target");
  return new F(function(a) {
    var c = function() {
      for (var u = [], l = 0; l < arguments.length; l++)
        u[l] = arguments[l];
      return a.next(1 < u.length ? u : u[0]);
    };
    return o(c), function() {
      return s(c);
    };
  });
}
function wn(t, e) {
  return function(n) {
    return function(r) {
      return t[n](e, r);
    };
  };
}
function eo(t) {
  return C(t.addListener) && C(t.removeListener);
}
function to(t) {
  return C(t.on) && C(t.off);
}
function no(t) {
  return C(t.addEventListener) && C(t.removeEventListener);
}
function ro() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = ir(t), r = Ii(t, 1 / 0), i = t;
  return i.length ? i.length === 1 ? Q(i[0]) : Ji(r)(yr(i, n)) : Ei;
}
function io(t, e) {
  return G(function(n, r) {
    var i = 0;
    n.subscribe(V(r, function(o) {
      return t.call(e, o, i++) && r.next(o);
    }));
  });
}
function oo(t, e, n, r, i) {
  return function(o, s) {
    var a = n, c = e, u = 0;
    o.subscribe(V(s, function(l) {
      var p = u++;
      c = a ? t(c, l, p) : (a = !0, l), r && s.next(c);
    }, i && function() {
      a && s.next(c), s.complete();
    }));
  };
}
function so(t, e) {
  return C(e) ? He(t, e, 1) : He(t, 1);
}
function It(t, e) {
  return e === void 0 && (e = lt), t = t ?? ao, G(function(n, r) {
    var i, o = !0;
    n.subscribe(V(r, function(s) {
      var a = e(s);
      (o || !t(i, a)) && (o = !1, i = a, r.next(s));
    }));
  });
}
function ao(t, e) {
  return t === e;
}
function uo(t, e) {
  return G(oo(t, e, arguments.length >= 2, !0));
}
function br(t) {
  t === void 0 && (t = {});
  var e = t.connector, n = e === void 0 ? function() {
    return new ue();
  } : e, r = t.resetOnError, i = r === void 0 ? !0 : r, o = t.resetOnComplete, s = o === void 0 ? !0 : o, a = t.resetOnRefCountZero, c = a === void 0 ? !0 : a;
  return function(u) {
    var l, p, f, h = 0, g = !1, d = !1, _ = function() {
      p == null || p.unsubscribe(), p = void 0;
    }, x = function() {
      _(), l = f = void 0, g = d = !1;
    }, m = function() {
      var D = l;
      x(), D == null || D.unsubscribe();
    };
    return G(function(D, Z) {
      h++, !d && !g && _();
      var W = f = f ?? n();
      Z.add(function() {
        h--, h === 0 && !d && !g && (p = Pt(m, c));
      }), W.subscribe(Z), !l && h > 0 && (l = new Ve({
        next: function(y) {
          return W.next(y);
        },
        error: function(y) {
          d = !0, _(), p = Pt(x, i, y), W.error(y);
        },
        complete: function() {
          g = !0, _(), p = Pt(x, s), W.complete();
        }
      }), Q(D).subscribe(l));
    })(u);
  };
}
function Pt(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (e === !0) {
    t();
    return;
  }
  if (e !== !1) {
    var i = new Ve({
      next: function() {
        i.unsubscribe(), t();
      }
    });
    return Q(e.apply(void 0, _e([], fe(n)))).subscribe(i);
  }
}
function co(t, e, n) {
  var r, i, o, s, a = !1;
  return t && typeof t == "object" ? (r = t.bufferSize, s = r === void 0 ? 1 / 0 : r, i = t.windowTime, e = i === void 0 ? 1 / 0 : i, o = t.refCount, a = o === void 0 ? !1 : o, n = t.scheduler) : s = t ?? 1 / 0, br({
    connector: function() {
      return new Ie(s, e, n);
    },
    resetOnError: !0,
    resetOnComplete: !1,
    resetOnRefCountZero: a
  });
}
function gr(t, e) {
  return G(function(n, r) {
    var i = null, o = 0, s = !1, a = function() {
      return s && !i && r.complete();
    };
    n.subscribe(V(r, function(c) {
      i == null || i.unsubscribe();
      var u = 0, l = o++;
      Q(t(c, l)).subscribe(i = V(r, function(p) {
        return r.next(e ? e(c, p, l, u++) : p);
      }, function() {
        i = null, a();
      }));
    }, function() {
      s = !0, a();
    }));
  });
}
function N(t, e, n) {
  var r = C(t) || e || n ? { next: t, error: e, complete: n } : t;
  return r ? G(function(i, o) {
    var s;
    (s = r.subscribe) === null || s === void 0 || s.call(r);
    var a = !0;
    i.subscribe(V(o, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), o.next(c);
    }, function() {
      var c;
      a = !1, (c = r.complete) === null || c === void 0 || c.call(r), o.complete();
    }, function(c) {
      var u;
      a = !1, (u = r.error) === null || u === void 0 || u.call(r, c), o.error(c);
    }, function() {
      var c, u;
      a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : lt;
}
function lo() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = ki(t);
  return G(function(r, i) {
    for (var o = t.length, s = new Array(o), a = t.map(function() {
      return !1;
    }), c = !1, u = function(p) {
      Q(t[p]).subscribe(V(i, function(f) {
        s[p] = f, !c && !a[p] && (a[p] = !0, (c = a.every(lt)) && (a = null));
      }, Ft));
    }, l = 0; l < o; l++)
      u(l);
    r.subscribe(V(i, function(p) {
      if (c) {
        var f = _e([p], fe(s));
        i.next(n ? n.apply(void 0, _e([], fe(f))) : f);
      }
    }));
  });
}
const fo = () => ({
  connected: new Ie(),
  accounts: new Ie(),
  persona: new Ie(),
  onInit: new Ie(),
  state$: new Ie(),
  setState: new ue()
});
function Ct(t, e, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(s) {
      s(o);
    });
  }
  return new (n || (n = Promise))(function(o, s) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (p) {
        s(p);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (p) {
        s(p);
      }
    }
    function u(l) {
      l.done ? o(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function Rt(t, e) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < o[1]) {
              n.label = o[1], o = u;
              break;
            }
            if (o && n.label < o[2]) {
              n.label = o[2], n.ops.push(u);
              break;
            }
            o[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], i = 0;
      } finally {
        r = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function yt(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), i, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
      o.push(i.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}
function je(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, o; r < i; r++)
      (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}
var ho = {
  withStackTrace: !1
}, wr = function(t, e, n) {
  n === void 0 && (n = ho);
  var r = e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, i = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: t,
    stack: i
  };
}, oe = (
  /** @class */
  function() {
    function t(e) {
      this._promise = e;
    }
    return t.fromSafePromise = function(e) {
      var n = e.then(function(r) {
        return new ve(r);
      });
      return new t(n);
    }, t.fromPromise = function(e, n) {
      var r = e.then(function(i) {
        return new ve(i);
      }).catch(function(i) {
        return new Ce(n(i));
      });
      return new t(r);
    }, t.combine = function(e) {
      return vo(e);
    }, t.combineWithAllErrors = function(e) {
      return yo(e);
    }, t.prototype.map = function(e) {
      var n = this;
      return new t(this._promise.then(function(r) {
        return Ct(n, void 0, void 0, function() {
          var i;
          return Rt(this, function(o) {
            switch (o.label) {
              case 0:
                return r.isErr() ? [2, new Ce(r.error)] : (i = ve.bind, [4, e(r.value)]);
              case 1:
                return [2, new (i.apply(ve, [void 0, o.sent()]))()];
            }
          });
        });
      }));
    }, t.prototype.mapErr = function(e) {
      var n = this;
      return new t(this._promise.then(function(r) {
        return Ct(n, void 0, void 0, function() {
          var i;
          return Rt(this, function(o) {
            switch (o.label) {
              case 0:
                return r.isOk() ? [2, new ve(r.value)] : (i = Ce.bind, [4, e(r.error)]);
              case 1:
                return [2, new (i.apply(Ce, [void 0, o.sent()]))()];
            }
          });
        });
      }));
    }, t.prototype.andThen = function(e) {
      return new t(this._promise.then(function(n) {
        if (n.isErr())
          return new Ce(n.error);
        var r = e(n.value);
        return r instanceof t ? r._promise : r;
      }));
    }, t.prototype.orElse = function(e) {
      var n = this;
      return new t(this._promise.then(function(r) {
        return Ct(n, void 0, void 0, function() {
          return Rt(this, function(i) {
            return r.isErr() ? [2, e(r.error)] : [2, new ve(r.value)];
          });
        });
      }));
    }, t.prototype.match = function(e, n) {
      return this._promise.then(function(r) {
        return r.match(e, n);
      });
    }, t.prototype.unwrapOr = function(e) {
      return this._promise.then(function(n) {
        return n.unwrapOr(e);
      });
    }, t.prototype.then = function(e, n) {
      return this._promise.then(e, n);
    }, t;
  }()
), po = function(t) {
  return new oe(Promise.resolve(new ve(t)));
}, _n = function(t) {
  return new oe(Promise.resolve(new Ce(t)));
};
oe.fromPromise;
oe.fromSafePromise;
var mo = function(t) {
  return function(e) {
    return je(je([], yt(e), !1), [t], !1);
  };
}, _r = function(t) {
  return t.reduce(function(e, n) {
    return e.isOk() ? n.isErr() ? ce(n.error) : e.map(mo(n.value)) : e;
  }, ne([]));
}, vo = function(t) {
  return oe.fromSafePromise(Promise.all(t)).andThen(_r);
}, xr = function(t) {
  return t.reduce(function(e, n) {
    return n.isErr() ? e.isErr() ? ce(je(je([], yt(e.error), !1), [n.error], !1)) : ce([n.error]) : e.isErr() ? e : ne(je(je([], yt(e.value), !1), [n.value], !1));
  }, ne([]));
}, yo = function(t) {
  return oe.fromSafePromise(Promise.all(t)).andThen(xr);
}, Bt;
(function(t) {
  function e(i, o) {
    return function() {
      for (var s = [], a = 0; a < arguments.length; a++)
        s[a] = arguments[a];
      try {
        var c = i.apply(void 0, je([], yt(s), !1));
        return ne(c);
      } catch (u) {
        return ce(o ? o(u) : u);
      }
    };
  }
  t.fromThrowable = e;
  function n(i) {
    return _r(i);
  }
  t.combine = n;
  function r(i) {
    return xr(i);
  }
  t.combineWithAllErrors = r;
})(Bt || (Bt = {}));
var ne = function(t) {
  return new ve(t);
}, ce = function(t) {
  return new Ce(t);
}, ve = (
  /** @class */
  function() {
    function t(e) {
      this.value = e;
    }
    return t.prototype.isOk = function() {
      return !0;
    }, t.prototype.isErr = function() {
      return !this.isOk();
    }, t.prototype.map = function(e) {
      return ne(e(this.value));
    }, t.prototype.mapErr = function(e) {
      return ne(this.value);
    }, t.prototype.andThen = function(e) {
      return e(this.value);
    }, t.prototype.orElse = function(e) {
      return ne(this.value);
    }, t.prototype.asyncAndThen = function(e) {
      return e(this.value);
    }, t.prototype.asyncMap = function(e) {
      return oe.fromSafePromise(e(this.value));
    }, t.prototype.unwrapOr = function(e) {
      return this.value;
    }, t.prototype.match = function(e, n) {
      return e(this.value);
    }, t.prototype._unsafeUnwrap = function(e) {
      return this.value;
    }, t.prototype._unsafeUnwrapErr = function(e) {
      throw wr("Called `_unsafeUnwrapErr` on an Ok", this, e);
    }, t;
  }()
), Ce = (
  /** @class */
  function() {
    function t(e) {
      this.error = e;
    }
    return t.prototype.isOk = function() {
      return !1;
    }, t.prototype.isErr = function() {
      return !this.isOk();
    }, t.prototype.map = function(e) {
      return ce(this.error);
    }, t.prototype.mapErr = function(e) {
      return ce(e(this.error));
    }, t.prototype.andThen = function(e) {
      return ce(this.error);
    }, t.prototype.orElse = function(e) {
      return e(this.error);
    }, t.prototype.asyncAndThen = function(e) {
      return _n(this.error);
    }, t.prototype.asyncMap = function(e) {
      return _n(this.error);
    }, t.prototype.unwrapOr = function(e) {
      return e;
    }, t.prototype.match = function(e, n) {
      return n(this.error);
    }, t.prototype._unsafeUnwrap = function(e) {
      throw wr("Called `_unsafeUnwrap` on an Err", this, e);
    }, t.prototype._unsafeUnwrapErr = function(e) {
      return this.error;
    }, t;
  }()
);
Bt.fromThrowable;
const bo = (t, e) => e ? !t || !(e != null && e.quantity) || !(e != null && e.quantifier) ? !1 : e.quantifier === "exactly" ? t.length === e.quantity : t.length >= e.quantity : !0, xn = (t, {
  state: e,
  logger: n,
  walletClient: r
}) => {
  if ([
    !!(e != null && e.persona),
    bo(
      e == null ? void 0 : e.accounts,
      t.ongoingAccountsWithoutProofOfOwnership
    )
  ].reduce((o, s) => o && s, !0) && !t.oneTimeAccountsWithoutProofOfOwnership) {
    n == null || n.debug("resolveByState", e);
    const o = {
      accounts: e == null ? void 0 : e.accounts,
      persona: e == null ? void 0 : e.persona
    };
    return po({
      resolvedBy: "state",
      data: o,
      persist: !1
    });
  }
  return n == null || n.debug("resolveByWalletRequest"), r.request(t).map((o) => ({
    resolvedBy: "wallet",
    persist: !t.oneTimeAccountsWithoutProofOfOwnership,
    data: o
  }));
}, Sn = (t, e) => e.persona ? {
  ...t,
  usePersona: {
    discriminator: "usePersona",
    identityAddress: e.persona.identityAddress
  }
} : { ...t, loginWithoutChallenge: { discriminator: "login" } }, zt = (t) => t, Sr = (t) => {
  try {
    return ne(JSON.parse(t));
  } catch (e) {
    return ce(zt(e));
  }
}, go = (t) => {
  try {
    return ne(JSON.stringify(t));
  } catch (e) {
    return ce(e);
  }
}, wo = (t) => go(t).andThen(Sr), $t = {
  connected: !1,
  accounts: []
}, _o = (t) => {
  const e = t.key, n = t.subjects || fo(), r = t.logger, i = t.connectButtonClient, o = t.walletClient, s = t.storageClient, a = t.useDoneCallback, c = t.onDisconnectCallback, u = new Te(), l = () => s.getData(e).map((y) => (y && (r == null || r.debug("readFromStorage")), y)), p = (y) => s.setData(e, y).map(() => {
    r == null || r.debug("writeToStorage", y);
  }), f = (y, K = !1) => {
    wo(y).map((q) => {
      Object.keys(q).length && n.setState.next({ state: q, persist: K });
    });
  }, h = () => {
    n.setState.next({ state: $t, persist: !0 });
  }, g = (y) => (t != null && t.onInitCallback && (t == null || t.onInitCallback(y)), f(y));
  (() => t.initialState ? (r == null || r.debug("initializeStateFromInput"), g(t.initialState)) : l().map((y) => y ? (r == null || r.debug("initializeStateFromStorage"), g(y)) : (r == null || r.debug("initializeStateFromDefault"), g($t))))();
  const _ = n.state$.pipe(br(), co()), x = _.pipe(
    be(({ connected: y }) => y),
    It()
  ), m = _.pipe(
    be(({ persona: y }) => y),
    It()
  ), D = _.pipe(be(({ accounts: y }) => y));
  u.add(
    _.pipe(
      N((y) => {
        r == null || r.debug("state$", y);
      })
    ).subscribe()
  ), u.add(
    D.pipe(
      N((y) => {
        i.setAccounts(y || []);
      })
    ).subscribe()
  ), u.add(
    m.pipe(
      N((y) => {
        i.setPersonaLabel((y == null ? void 0 : y.label) ?? "");
      })
    ).subscribe()
  ), u.add(
    i.onDisconnect$.pipe(
      N(() => {
        h(), o.resetRequestItems(), c();
      })
    ).subscribe()
  ), u.add(
    o.pendingRequests$.pipe(
      N((y) => {
        i.setLoading(y);
      })
    ).subscribe()
  ), u.add(
    o.requestItems$.pipe(
      N((y) => {
        i.setRequestItems(y);
      })
    ).subscribe()
  ), u.add(
    x.pipe(
      N((y) => {
        i.setConnected(y);
      })
    ).subscribe()
  ), u.add(
    n.setState.pipe(
      so(
        ({ state: y, persist: K }) => Fi(y).pipe(
          uo((q, S) => ({ ...q, ...S }), $t),
          He((q) => (r == null || r.debug("stateUpdated", q), n.state$.next(q), K ? p(q) : []))
        )
      )
    ).subscribe()
  );
  const Z = () => oe.fromPromise(
    zi(_),
    (y) => y
  ), W = ({ accounts: y }) => Z().andThen((K) => xn(
    Sn(
      {
        [y != null && y.oneTime ? "oneTimeAccountsWithoutProofOfOwnership" : "ongoingAccountsWithoutProofOfOwnership"]: y
      },
      K
    ),
    {
      state: K,
      logger: r,
      walletClient: o
    }
  ).map(({ data: q, resolvedBy: S, persist: ee }) => (S === "wallet" && ee && f({ ...q, connected: K.connected }, !0), q)));
  return u.add(
    i.onConnect$.pipe(
      N(() => {
        r == null || r.debug("onConnect");
      }),
      lo(_),
      gr(([, y]) => {
        var K;
        return ((K = t.connectRequest) == null ? void 0 : K.call(t, (q) => (r == null || r.debug("connectRequest", q), i.setConnecting(!0), xn(
          Sn(
            {
              ongoingAccountsWithoutProofOfOwnership: q.accounts
            },
            y
          ),
          {
            state: y,
            logger: r,
            walletClient: o
          }
        ).map(({ data: S }) => (a || (f({ ...S, connected: !0 }, !0), i.setConnecting(!1)), {
          data: S,
          done: () => {
            f({ ...S, connected: !0 }, !0), i.setConnecting(!1);
          }
        })).mapErr((S) => (f({ connected: !1 }, !0), i.setConnecting(!1), S))))) ?? [];
      })
    ).subscribe()
  ), {
    connected$: _.pipe(
      be(({ connected: y }) => y),
      It()
    ),
    setConnected: (y) => n.connected.next(y),
    requestData: W,
    destroy: () => {
      i.destroy(), o.destroy(), u.unsubscribe();
    },
    subjects: n,
    state$: _
  };
}, xo = () => ({
  onConnect: new ue(),
  onDisconnect: new ue(),
  loading: new me(!1),
  connected: new Ie(),
  requestItems: new me([]),
  onCancelRequestItem: new ue(),
  accounts: new me([]),
  connecting: new me(!1),
  showNotification: new me(!1),
  personaLabel: new me("")
}), So = (t) => {
  import("./connect-button-e431ab55.mjs");
  const e = t.subjects || xo(), n = t.logger, r = (a) => {
    a();
  }, i = t.onConnect || r, o = () => document.querySelector("radix-connect-button"), s = new Te();
  return s.add(
    Pe(document, "onRender").pipe(
      be(() => o()),
      io((a) => !!a),
      gr((a) => {
        n == null || n.debug("connectButtonDiscovered"), a.dAppName = t.dAppName, t.explorer && (a.explorer = t.explorer);
        const c = Pe(a, "onConnect").pipe(
          N(() => {
            i((m) => e.onConnect.next(m));
          })
        ), u = Pe(
          a,
          "onDisconnect"
        ).pipe(
          N(() => {
            e.onDisconnect.next();
          })
        ), l = Pe(a, "onDestroy").pipe(
          N(() => {
            n == null || n.debug("connectButtonRemovedFromDOM");
          })
        ), p = Pe(
          a,
          "onCancelRequestItem"
        ).pipe(
          N((m) => {
            const D = m.detail.id;
            n == null || n.debug("onCancelRequestItem", { id: D }), e.onCancelRequestItem.next(D);
          })
        ), f = e.loading.pipe(
          N((m) => a.loading = m)
        ), h = e.connected.pipe(
          N((m) => {
            a.connected = m;
          })
        ), g = e.requestItems.pipe(
          N((m) => {
            a.requestItems = m;
          })
        ), d = e.accounts.pipe(
          N((m) => {
            a.accounts = m;
          })
        ), _ = e.personaLabel.pipe(
          N((m) => {
            a.personaLabel = m;
          })
        ), x = e.connecting.pipe(
          N((m) => {
            a.connecting = m;
          })
        );
        return ro(
          c,
          f,
          h,
          g,
          u,
          p,
          d,
          _,
          x,
          l
        );
      })
    ).subscribe()
  ), {
    onConnect$: e.onConnect.asObservable(),
    onDisconnect$: e.onDisconnect.asObservable(),
    onCancelRequestItem$: e.onCancelRequestItem.asObservable(),
    setLoading: (a) => e.loading.next(a),
    setConnecting: (a) => e.connecting.next(a),
    setConnected: (a) => e.connected.next(a),
    setRequestItems: (a) => e.requestItems.next(a),
    setAccounts: (a) => e.accounts.next(a),
    setPersonaLabel: (a) => e.personaLabel.next(a),
    destroy: () => {
      s.unsubscribe();
    }
  };
}, To = () => ({
  onChange: new ue(),
  items: new me([]),
  pendingItems: new me(!1)
}), Oo = (t) => {
  const e = t.logger, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), i = new Te(), o = t.subjects || To(), s = (h) => ({
    type: h,
    status: "pending",
    id: crypto.randomUUID()
  }), a = (h) => {
    const g = s(h);
    return n.set(g.id, g), r.add(g.id), o.onChange.next(), e == null || e.debug("addRequestItem", {
      id: g.id,
      status: g.status
    }), g;
  }, c = (h) => {
    n.has(h) && (n.delete(h), r.delete(h), o.onChange.next(), e == null || e.debug("removeRequestItem", h));
  }, u = () => {
    n.clear(), r.clear(), o.onChange.next(), e == null || e.debug("resetRequestItems");
  }, l = ({
    id: h,
    status: g,
    error: d,
    transactionIntentHash: _
  }) => {
    const x = n.get(h);
    if (x) {
      const m = {
        ...x,
        status: g
      };
      m.status === "fail" && (m.error = d), m.status === "success" && m.type === "sendTransaction" && (m.transactionIntentHash = _), n.set(h, m), o.onChange.next(), e == null || e.debug("updateRequestItemStatus", m);
    }
  }, p = () => [...r], f = () => p().map((h) => ({ id: h, ...n.get(h) })).filter((h) => !!h);
  return i.add(
    o.onChange.pipe(
      be(() => f()),
      N((h) => o.items.next(h))
    ).subscribe()
  ), {
    add: a,
    remove: c,
    updateStatus: l,
    reset: u,
    destroy: () => {
      i.unsubscribe();
    },
    items$: o.items.asObservable(),
    subjects: o
  };
}, Eo = (t) => {
  const e = t.logger, n = t.requestItemClient || Oo({
    logger: e
  }), r = t.walletSdk, i = ({
    oneTimeAccountsWithoutProofOfOwnership: a,
    ongoingAccountsWithoutProofOfOwnership: c,
    loginWithoutChallenge: u,
    usePersona: l
  }) => {
    const p = {};
    a && (p.oneTimeAccountsWithoutProofOfOwnership = a), c && (p.ongoingAccountsWithoutProofOfOwnership = c), u && (p.loginWithoutChallenge = u), l && (p.usePersona = l);
    const f = p.loginWithoutChallenge ? "loginRequest" : "dataRequest", { id: h } = n.add(f);
    return e == null || e.debug("walletRequest", p), r.request(p).map((g) => {
      const {
        persona: d,
        ongoingAccounts: _ = [],
        oneTimeAccounts: x = []
      } = g;
      return e == null || e.debug("walletSuccessResponse", g), n.updateStatus({ id: h, status: "success" }), {
        accounts: [..._, ...x],
        persona: d
      };
    }).mapErr((g) => (n.updateStatus({
      id: h,
      status: "fail",
      error: g.error
    }), e == null || e.debug("wallet error response", g), g));
  }, o = new Te();
  return o.add(
    n.items$.pipe(
      N((a) => {
        n.subjects.pendingItems.next(
          a.some((c) => c.status === "pending")
        );
      })
    ).subscribe()
  ), {
    request: i,
    sendTransaction: (a) => {
      const { id: c } = n.add("sendTransaction");
      return r.sendTransaction(a).map((u) => (n.updateStatus({
        id: c,
        status: "success",
        transactionIntentHash: u.transactionIntentHash
      }), e == null || e.debug("walletSuccessResponse", u), u)).mapErr((u) => (n.updateStatus({
        id: c,
        status: "fail",
        error: u.error
      }), e == null || e.debug("walletErrorResponse", u), u));
    },
    pendingRequests$: n.subjects.pendingItems.asObservable(),
    requestItems$: n.items$,
    resetRequestItems: n.reset,
    destroy: () => {
      n.destroy(), r.destroy(), o.unsubscribe();
    }
  };
}, Ao = () => {
  const t = (n) => new Promise((r, i) => {
    try {
      const o = localStorage.getItem(n);
      return r(o || void 0);
    } catch (o) {
      return i(o);
    }
  }), e = (n, r) => new Promise((i, o) => {
    try {
      return localStorage.setItem(n, JSON.stringify(r)), i();
    } catch (s) {
      return o(s);
    }
  });
  return {
    getData: (n) => oe.fromPromise(t(n), zt).andThen(
      (r) => r ? Sr(r) : ne(void 0)
    ),
    setData: (n, r) => oe.fromPromise(e(n, r), zt)
  };
};
var ko = Object.defineProperty, Io = (t, e, n) => e in t ? ko(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, it = (t, e, n) => (Io(t, typeof e != "symbol" ? e + "" : e, n), n), Kt = function(t, e) {
  return Kt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var i in r)
      Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
  }, Kt(t, e);
};
function Oe(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Kt(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
function Po(t, e, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(s) {
      s(o);
    });
  }
  return new (n || (n = Promise))(function(o, s) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (p) {
        s(p);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (p) {
        s(p);
      }
    }
    function u(l) {
      l.done ? o(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function Tr(t, e) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < o[1]) {
              n.label = o[1], o = u;
              break;
            }
            if (o && n.label < o[2]) {
              n.label = o[2], n.ops.push(u);
              break;
            }
            o[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], i = 0;
      } finally {
        r = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Ye(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Je(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), i, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
      o.push(i.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}
function Ge(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, o; r < i; r++)
      (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}
function Be(t) {
  return this instanceof Be ? (this.v = t, this) : new Be(t);
}
function Co(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), i, o = [];
  return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(f) {
    r[f] && (i[f] = function(h) {
      return new Promise(function(g, d) {
        o.push([f, h, g, d]) > 1 || a(f, h);
      });
    });
  }
  function a(f, h) {
    try {
      c(r[f](h));
    } catch (g) {
      p(o[0][3], g);
    }
  }
  function c(f) {
    f.value instanceof Be ? Promise.resolve(f.value.v).then(u, l) : p(o[0][2], f);
  }
  function u(f) {
    a("next", f);
  }
  function l(f) {
    a("throw", f);
  }
  function p(f, h) {
    f(h), o.shift(), o.length && a(o[0][0], o[0][1]);
  }
}
function Ro(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof Ye == "function" ? Ye(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(o) {
    n[o] = t[o] && function(s) {
      return new Promise(function(a, c) {
        s = t[o](s), i(a, c, s.done, s.value);
      });
    };
  }
  function i(o, s, a, c) {
    Promise.resolve(c).then(function(u) {
      o({ value: u, done: a });
    }, s);
  }
}
function L(t) {
  return typeof t == "function";
}
function cn(t) {
  var e = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = t(e);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var jt = cn(function(t) {
  return function(e) {
    t(this), this.message = e ? e.length + ` errors occurred during unsubscription:
` + e.map(function(n, r) {
      return r + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = e;
  };
});
function bt(t, e) {
  if (t) {
    var n = t.indexOf(e);
    0 <= n && t.splice(n, 1);
  }
}
var rt = function() {
  function t(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var e, n, r, i, o;
    if (!this.closed) {
      this.closed = !0;
      var s = this._parentage;
      if (s)
        if (this._parentage = null, Array.isArray(s))
          try {
            for (var a = Ye(s), c = a.next(); !c.done; c = a.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (d) {
            e = { error: d };
          } finally {
            try {
              c && !c.done && (n = a.return) && n.call(a);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          s.remove(this);
      var l = this.initialTeardown;
      if (L(l))
        try {
          l();
        } catch (d) {
          o = d instanceof jt ? d.errors : [d];
        }
      var p = this._finalizers;
      if (p) {
        this._finalizers = null;
        try {
          for (var f = Ye(p), h = f.next(); !h.done; h = f.next()) {
            var g = h.value;
            try {
              Tn(g);
            } catch (d) {
              o = o ?? [], d instanceof jt ? o = Ge(Ge([], Je(o)), Je(d.errors)) : o.push(d);
            }
          }
        } catch (d) {
          r = { error: d };
        } finally {
          try {
            h && !h.done && (i = f.return) && i.call(f);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (o)
        throw new jt(o);
    }
  }, t.prototype.add = function(e) {
    var n;
    if (e && e !== this)
      if (this.closed)
        Tn(e);
      else {
        if (e instanceof t) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e);
      }
  }, t.prototype._hasParent = function(e) {
    var n = this._parentage;
    return n === e || Array.isArray(n) && n.includes(e);
  }, t.prototype._addParent = function(e) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e;
  }, t.prototype._removeParent = function(e) {
    var n = this._parentage;
    n === e ? this._parentage = null : Array.isArray(n) && bt(n, e);
  }, t.prototype.remove = function(e) {
    var n = this._finalizers;
    n && bt(n, e), e instanceof t && e._removeParent(this);
  }, t.EMPTY = function() {
    var e = new t();
    return e.closed = !0, e;
  }(), t;
}(), Or = rt.EMPTY;
function Er(t) {
  return t instanceof rt || t && "closed" in t && L(t.remove) && L(t.add) && L(t.unsubscribe);
}
function Tn(t) {
  L(t) ? t() : t.unsubscribe();
}
var Ar = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, $o = {
  setTimeout: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    return setTimeout.apply(void 0, Ge([t, e], Je(n)));
  },
  clearTimeout: function(t) {
    return clearTimeout(t);
  },
  delegate: void 0
};
function kr(t) {
  $o.setTimeout(function() {
    throw t;
  });
}
function Vt() {
}
function vt(t) {
  t();
}
var ln = function(t) {
  Oe(e, t);
  function e(n) {
    var r = t.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, Er(n) && n.add(r)) : r.destination = Zo, r;
  }
  return e.create = function(n, r, i) {
    return new Qe(n, r, i);
  }, e.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, e.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(n) {
    this.destination.next(n);
  }, e.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(rt), jo = Function.prototype.bind;
function Nt(t, e) {
  return jo.call(t, e);
}
var No = function() {
  function t(e) {
    this.partialObserver = e;
  }
  return t.prototype.next = function(e) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(e);
      } catch (r) {
        ht(r);
      }
  }, t.prototype.error = function(e) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(e);
      } catch (r) {
        ht(r);
      }
    else
      ht(e);
  }, t.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (n) {
        ht(n);
      }
  }, t;
}(), Qe = function(t) {
  Oe(e, t);
  function e(n, r, i) {
    var o = t.call(this) || this, s;
    if (L(n) || !n)
      s = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: i ?? void 0
      };
    else {
      var a;
      o && Ar.useDeprecatedNextContext ? (a = Object.create(n), a.unsubscribe = function() {
        return o.unsubscribe();
      }, s = {
        next: n.next && Nt(n.next, a),
        error: n.error && Nt(n.error, a),
        complete: n.complete && Nt(n.complete, a)
      }) : s = n;
    }
    return o.destination = new No(s), o;
  }
  return e;
}(ln);
function ht(t) {
  kr(t);
}
function Lo(t) {
  throw t;
}
var Zo = {
  closed: !0,
  next: Vt,
  error: Lo,
  complete: Vt
}, fn = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Ot(t) {
  return t;
}
function Do(t) {
  return t.length === 0 ? Ot : t.length === 1 ? t[0] : function(e) {
    return t.reduce(function(n, r) {
      return r(n);
    }, e);
  };
}
var B = function() {
  function t(e) {
    e && (this._subscribe = e);
  }
  return t.prototype.lift = function(e) {
    var n = new t();
    return n.source = this, n.operator = e, n;
  }, t.prototype.subscribe = function(e, n, r) {
    var i = this, o = Uo(e) ? e : new Qe(e, n, r);
    return vt(function() {
      var s = i, a = s.operator, c = s.source;
      o.add(a ? a.call(o, c) : c ? i._subscribe(o) : i._trySubscribe(o));
    }), o;
  }, t.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (n) {
      e.error(n);
    }
  }, t.prototype.forEach = function(e, n) {
    var r = this;
    return n = On(n), new n(function(i, o) {
      var s = new Qe({
        next: function(a) {
          try {
            e(a);
          } catch (c) {
            o(c), s.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
      r.subscribe(s);
    });
  }, t.prototype._subscribe = function(e) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e);
  }, t.prototype[fn] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var e = [], n = 0; n < arguments.length; n++)
      e[n] = arguments[n];
    return Do(e)(this);
  }, t.prototype.toPromise = function(e) {
    var n = this;
    return e = On(e), new e(function(r, i) {
      var o;
      n.subscribe(function(s) {
        return o = s;
      }, function(s) {
        return i(s);
      }, function() {
        return r(o);
      });
    });
  }, t.create = function(e) {
    return new t(e);
  }, t;
}();
function On(t) {
  var e;
  return (e = t ?? Ar.Promise) !== null && e !== void 0 ? e : Promise;
}
function qo(t) {
  return t && L(t.next) && L(t.error) && L(t.complete);
}
function Uo(t) {
  return t && t instanceof ln || qo(t) && Er(t);
}
function Wo(t) {
  return L(t == null ? void 0 : t.lift);
}
function X(t) {
  return function(e) {
    if (Wo(e))
      return e.lift(function(n) {
        try {
          return t(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function se(t, e, n, r, i) {
  return new Mo(t, e, n, r, i);
}
var Mo = function(t) {
  Oe(e, t);
  function e(n, r, i, o, s, a) {
    var c = t.call(this, n) || this;
    return c.onFinalize = s, c.shouldUnsubscribe = a, c._next = r ? function(u) {
      try {
        r(u);
      } catch (l) {
        n.error(l);
      }
    } : t.prototype._next, c._error = o ? function(u) {
      try {
        o(u);
      } catch (l) {
        n.error(l);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._error, c._complete = i ? function() {
      try {
        i();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      t.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, e;
}(ln), Fo = cn(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), ye = function(t) {
  Oe(e, t);
  function e() {
    var n = t.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return e.prototype.lift = function(n) {
    var r = new En(this, this);
    return r.operator = n, r;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new Fo();
  }, e.prototype.next = function(n) {
    var r = this;
    vt(function() {
      var i, o;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var s = Ye(r.currentObservers), a = s.next(); !a.done; a = s.next()) {
            var c = a.value;
            c.next(n);
          }
        } catch (u) {
          i = { error: u };
        } finally {
          try {
            a && !a.done && (o = s.return) && o.call(s);
          } finally {
            if (i)
              throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(n) {
    var r = this;
    vt(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var i = r.observers; i.length; )
          i.shift().error(n);
      }
    });
  }, e.prototype.complete = function() {
    var n = this;
    vt(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, n);
  }, e.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, e.prototype._innerSubscribe = function(n) {
    var r = this, i = this, o = i.hasError, s = i.isStopped, a = i.observers;
    return o || s ? Or : (this.currentObservers = null, a.push(n), new rt(function() {
      r.currentObservers = null, bt(a, n);
    }));
  }, e.prototype._checkFinalizedStatuses = function(n) {
    var r = this, i = r.hasError, o = r.thrownError, s = r.isStopped;
    i ? n.error(o) : s && n.complete();
  }, e.prototype.asObservable = function() {
    var n = new B();
    return n.source = this, n;
  }, e.create = function(n, r) {
    return new En(n, r);
  }, e;
}(B), En = function(t) {
  Oe(e, t);
  function e(n, r) {
    var i = t.call(this) || this;
    return i.destination = n, i.source = r, i;
  }
  return e.prototype.next = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || i === void 0 || i.call(r, n);
  }, e.prototype.error = function(n) {
    var r, i;
    (i = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || i === void 0 || i.call(r, n);
  }, e.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, e.prototype._subscribe = function(n) {
    var r, i;
    return (i = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && i !== void 0 ? i : Or;
  }, e;
}(ye), Bo = {
  now: function() {
    return Date.now();
  },
  delegate: void 0
}, zo = function(t) {
  Oe(e, t);
  function e(n, r) {
    return t.call(this) || this;
  }
  return e.prototype.schedule = function(n, r) {
    return this;
  }, e;
}(rt), Ht = {
  setInterval: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var i = Ht.delegate;
    return i != null && i.setInterval ? i.setInterval.apply(i, Ge([t, e], Je(n))) : setInterval.apply(void 0, Ge([t, e], Je(n)));
  },
  clearInterval: function(t) {
    return clearInterval(t);
  },
  delegate: void 0
}, Ko = function(t) {
  Oe(e, t);
  function e(n, r) {
    var i = t.call(this, n, r) || this;
    return i.scheduler = n, i.work = r, i.pending = !1, i;
  }
  return e.prototype.schedule = function(n, r) {
    var i;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var o = this.id, s = this.scheduler;
    return o != null && (this.id = this.recycleAsyncId(s, o, r)), this.pending = !0, this.delay = r, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(s, this.id, r), this;
  }, e.prototype.requestAsyncId = function(n, r, i) {
    return i === void 0 && (i = 0), Ht.setInterval(n.flush.bind(n, this), i);
  }, e.prototype.recycleAsyncId = function(n, r, i) {
    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === !1)
      return r;
    r != null && Ht.clearInterval(r);
  }, e.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var i = this._execute(n, r);
    if (i)
      return i;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(n, r) {
    var i = !1, o;
    try {
      this.work(n);
    } catch (s) {
      i = !0, o = s || new Error("Scheduled action threw falsy error");
    }
    if (i)
      return this.unsubscribe(), o;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, i = n.scheduler, o = i.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, bt(o, this), r != null && (this.id = this.recycleAsyncId(i, r, null)), this.delay = null, t.prototype.unsubscribe.call(this);
    }
  }, e;
}(zo), An = function() {
  function t(e, n) {
    n === void 0 && (n = t.now), this.schedulerActionCtor = e, this.now = n;
  }
  return t.prototype.schedule = function(e, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, e).schedule(r, n);
  }, t.now = Bo.now, t;
}(), Vo = function(t) {
  Oe(e, t);
  function e(n, r) {
    r === void 0 && (r = An.now);
    var i = t.call(this, n, r) || this;
    return i.actions = [], i._active = !1, i;
  }
  return e.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var i;
    this._active = !0;
    do
      if (i = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = !1, i) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw i;
    }
  }, e;
}(An), Ho = new Vo(Ko), Yo = Ho, Ir = new B(function(t) {
  return t.complete();
});
function Pr(t) {
  return t && L(t.schedule);
}
function Cr(t) {
  return t[t.length - 1];
}
function Rr(t) {
  return Pr(Cr(t)) ? t.pop() : void 0;
}
function Jo(t, e) {
  return typeof Cr(t) == "number" ? t.pop() : e;
}
var $r = function(t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
function jr(t) {
  return L(t == null ? void 0 : t.then);
}
function Nr(t) {
  return L(t[fn]);
}
function Lr(t) {
  return Symbol.asyncIterator && L(t == null ? void 0 : t[Symbol.asyncIterator]);
}
function Zr(t) {
  return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Go() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var Dr = Go();
function qr(t) {
  return L(t == null ? void 0 : t[Dr]);
}
function Ur(t) {
  return Co(this, arguments, function() {
    var e, n, r, i;
    return Tr(this, function(o) {
      switch (o.label) {
        case 0:
          e = t.getReader(), o.label = 1;
        case 1:
          o.trys.push([1, , 9, 10]), o.label = 2;
        case 2:
          return [4, Be(e.read())];
        case 3:
          return n = o.sent(), r = n.value, i = n.done, i ? [4, Be(void 0)] : [3, 5];
        case 4:
          return [2, o.sent()];
        case 5:
          return [4, Be(r)];
        case 6:
          return [4, o.sent()];
        case 7:
          return o.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return e.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function Wr(t) {
  return L(t == null ? void 0 : t.getReader);
}
function Ee(t) {
  if (t instanceof B)
    return t;
  if (t != null) {
    if (Nr(t))
      return Qo(t);
    if ($r(t))
      return Xo(t);
    if (jr(t))
      return es(t);
    if (Lr(t))
      return Mr(t);
    if (qr(t))
      return ts(t);
    if (Wr(t))
      return ns(t);
  }
  throw Zr(t);
}
function Qo(t) {
  return new B(function(e) {
    var n = t[fn]();
    if (L(n.subscribe))
      return n.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function Xo(t) {
  return new B(function(e) {
    for (var n = 0; n < t.length && !e.closed; n++)
      e.next(t[n]);
    e.complete();
  });
}
function es(t) {
  return new B(function(e) {
    t.then(function(n) {
      e.closed || (e.next(n), e.complete());
    }, function(n) {
      return e.error(n);
    }).then(null, kr);
  });
}
function ts(t) {
  return new B(function(e) {
    var n, r;
    try {
      for (var i = Ye(t), o = i.next(); !o.done; o = i.next()) {
        var s = o.value;
        if (e.next(s), e.closed)
          return;
      }
    } catch (a) {
      n = { error: a };
    } finally {
      try {
        o && !o.done && (r = i.return) && r.call(i);
      } finally {
        if (n)
          throw n.error;
      }
    }
    e.complete();
  });
}
function Mr(t) {
  return new B(function(e) {
    rs(t, e).catch(function(n) {
      return e.error(n);
    });
  });
}
function ns(t) {
  return Mr(Ur(t));
}
function rs(t, e) {
  var n, r, i, o;
  return Po(this, void 0, void 0, function() {
    var s, a;
    return Tr(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = Ro(t), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (s = r.value, e.next(s), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return a = c.sent(), i = { error: a }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (o = n.return) ? [4, o.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i)
            throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function we(t, e, n, r, i) {
  r === void 0 && (r = 0), i === void 0 && (i = !1);
  var o = e.schedule(function() {
    n(), i ? t.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (t.add(o), !i)
    return o;
}
function Fr(t, e) {
  return e === void 0 && (e = 0), X(function(n, r) {
    n.subscribe(se(r, function(i) {
      return we(r, t, function() {
        return r.next(i);
      }, e);
    }, function() {
      return we(r, t, function() {
        return r.complete();
      }, e);
    }, function(i) {
      return we(r, t, function() {
        return r.error(i);
      }, e);
    }));
  });
}
function Br(t, e) {
  return e === void 0 && (e = 0), X(function(n, r) {
    r.add(t.schedule(function() {
      return n.subscribe(r);
    }, e));
  });
}
function is(t, e) {
  return Ee(t).pipe(Br(e), Fr(e));
}
function os(t, e) {
  return Ee(t).pipe(Br(e), Fr(e));
}
function ss(t, e) {
  return new B(function(n) {
    var r = 0;
    return e.schedule(function() {
      r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule());
    });
  });
}
function as(t, e) {
  return new B(function(n) {
    var r;
    return we(n, e, function() {
      r = t[Dr](), we(n, e, function() {
        var i, o, s;
        try {
          i = r.next(), o = i.value, s = i.done;
        } catch (a) {
          n.error(a);
          return;
        }
        s ? n.complete() : n.next(o);
      }, 0, !0);
    }), function() {
      return L(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function zr(t, e) {
  if (!t)
    throw new Error("Iterable cannot be null");
  return new B(function(n) {
    we(n, e, function() {
      var r = t[Symbol.asyncIterator]();
      we(n, e, function() {
        r.next().then(function(i) {
          i.done ? n.complete() : n.next(i.value);
        });
      }, 0, !0);
    });
  });
}
function us(t, e) {
  return zr(Ur(t), e);
}
function cs(t, e) {
  if (t != null) {
    if (Nr(t))
      return is(t, e);
    if ($r(t))
      return ss(t, e);
    if (jr(t))
      return os(t, e);
    if (Lr(t))
      return zr(t, e);
    if (qr(t))
      return as(t, e);
    if (Wr(t))
      return us(t, e);
  }
  throw Zr(t);
}
function Kr(t, e) {
  return e ? cs(t, e) : Ee(t);
}
function ls() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = Rr(t);
  return Kr(t, n);
}
var dn = cn(function(t) {
  return function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function fs(t, e) {
  var n = typeof e == "object";
  return new Promise(function(r, i) {
    var o = new Qe({
      next: function(s) {
        r(s), o.unsubscribe();
      },
      error: i,
      complete: function() {
        n ? r(e.defaultValue) : i(new dn());
      }
    });
    t.subscribe(o);
  });
}
function ds(t) {
  return t instanceof Date && !isNaN(t);
}
function st(t, e) {
  return X(function(n, r) {
    var i = 0;
    n.subscribe(se(r, function(o) {
      r.next(t.call(e, o, i++));
    }));
  });
}
function hs(t, e, n, r, i, o, s, a) {
  var c = [], u = 0, l = 0, p = !1, f = function() {
    p && !c.length && !u && e.complete();
  }, h = function(d) {
    return u < r ? g(d) : c.push(d);
  }, g = function(d) {
    o && e.next(d), u++;
    var _ = !1;
    Ee(n(d, l++)).subscribe(se(e, function(x) {
      i == null || i(x), o ? h(x) : e.next(x);
    }, function() {
      _ = !0;
    }, void 0, function() {
      if (_)
        try {
          u--;
          for (var x = function() {
            var m = c.shift();
            s ? we(e, s, function() {
              return g(m);
            }) : g(m);
          }; c.length && u < r; )
            x();
          f();
        } catch (m) {
          e.error(m);
        }
    }));
  };
  return t.subscribe(se(e, h, function() {
    p = !0, f();
  })), function() {
    a == null || a();
  };
}
function Vr(t, e, n) {
  return n === void 0 && (n = 1 / 0), L(e) ? Vr(function(r, i) {
    return st(function(o, s) {
      return e(r, o, i, s);
    })(Ee(t(r, i)));
  }, n) : (typeof e == "number" && (n = e), X(function(r, i) {
    return hs(r, i, t, n);
  }));
}
function ps(t) {
  return t === void 0 && (t = 1 / 0), Vr(Ot, t);
}
function ms(t, e, n) {
  t === void 0 && (t = 0), n === void 0 && (n = Yo);
  var r = -1;
  return e != null && (Pr(e) ? n = e : r = e), new B(function(i) {
    var o = ds(t) ? +t - n.now() : t;
    o < 0 && (o = 0);
    var s = 0;
    return n.schedule(function() {
      i.closed || (i.next(s++), 0 <= r ? this.schedule(void 0, r) : i.complete());
    }, o);
  });
}
function Lt() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = Rr(t), r = Jo(t, 1 / 0), i = t;
  return i.length ? i.length === 1 ? Ee(i[0]) : ps(r)(Kr(i, n)) : Ir;
}
function at(t, e) {
  return X(function(n, r) {
    var i = 0;
    n.subscribe(se(r, function(o) {
      return t.call(e, o, i++) && r.next(o);
    }));
  });
}
function vs(t) {
  return X(function(e, n) {
    var r = !1;
    e.subscribe(se(n, function(i) {
      r = !0, n.next(i);
    }, function() {
      r || n.next(t), n.complete();
    }));
  });
}
function ys(t) {
  return t <= 0 ? function() {
    return Ir;
  } : X(function(e, n) {
    var r = 0;
    e.subscribe(se(n, function(i) {
      ++r <= t && (n.next(i), t <= r && n.complete());
    }));
  });
}
function bs(t) {
  return t === void 0 && (t = gs), X(function(e, n) {
    var r = !1;
    e.subscribe(se(n, function(i) {
      r = !0, n.next(i);
    }, function() {
      return r ? n.complete() : n.error(t());
    }));
  });
}
function gs() {
  return new dn();
}
function kn(t, e) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(t ? at(function(i, o) {
      return t(i, o, r);
    }) : Ot, ys(1), n ? vs(e) : bs(function() {
      return new dn();
    }));
  };
}
function Hr(t) {
  t === void 0 && (t = {});
  var e = t.connector, n = e === void 0 ? function() {
    return new ye();
  } : e, r = t.resetOnError, i = r === void 0 ? !0 : r, o = t.resetOnComplete, s = o === void 0 ? !0 : o, a = t.resetOnRefCountZero, c = a === void 0 ? !0 : a;
  return function(u) {
    var l, p, f, h = 0, g = !1, d = !1, _ = function() {
      p == null || p.unsubscribe(), p = void 0;
    }, x = function() {
      _(), l = f = void 0, g = d = !1;
    }, m = function() {
      var D = l;
      x(), D == null || D.unsubscribe();
    };
    return X(function(D, Z) {
      h++, !d && !g && _();
      var W = f = f ?? n();
      Z.add(function() {
        h--, h === 0 && !d && !g && (p = Zt(m, c));
      }), W.subscribe(Z), !l && h > 0 && (l = new Qe({
        next: function(y) {
          return W.next(y);
        },
        error: function(y) {
          d = !0, _(), p = Zt(x, i, y), W.error(y);
        },
        complete: function() {
          g = !0, _(), p = Zt(x, s), W.complete();
        }
      }), Ee(D).subscribe(l));
    })(u);
  };
}
function Zt(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (e === !0) {
    t();
    return;
  }
  if (e !== !1) {
    var i = new Qe({
      next: function() {
        i.unsubscribe(), t();
      }
    });
    return e.apply(void 0, Ge([], Je(n))).subscribe(i);
  }
}
function ws(t) {
  return X(function(e, n) {
    Ee(t).subscribe(se(n, function() {
      return n.complete();
    }, Vt)), !n.closed && e.subscribe(n);
  });
}
function ze(t, e, n) {
  var r = L(t) || e || n ? { next: t, error: e, complete: n } : t;
  return r ? X(function(i, o) {
    var s;
    (s = r.subscribe) === null || s === void 0 || s.call(r);
    var a = !0;
    i.subscribe(se(o, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), o.next(c);
    }, function() {
      var c;
      a = !1, (c = r.complete) === null || c === void 0 || c.call(r), o.complete();
    }, function(c) {
      var u;
      a = !1, (u = r.error) === null || u === void 0 || u.call(r, c), o.error(c);
    }, function() {
      var c, u;
      a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : Ot;
}
const _s = () => ({
  outgoingMessageSubject: new ye(),
  incomingMessageSubject: new ye(),
  responseSubject: new ye(),
  messageLifeCycleEventSubject: new ye(),
  dispatchEventSubject: new ye()
}), Yt = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
}, xs = (t) => t.outgoingMessageSubject.pipe(
  st((e) => ({
    event: Yt.outgoingMessage,
    payload: e
  })),
  ze((e) => {
    t.dispatchEventSubject.next(e);
  }),
  Hr()
);
var ot = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Yr = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : e.log = n();
  })(ot, function() {
    var e = function() {
    }, n = "undefined", r = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), i = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ];
    function o(d, _) {
      var x = d[_];
      if (typeof x.bind == "function")
        return x.bind(d);
      try {
        return Function.prototype.bind.call(x, d);
      } catch {
        return function() {
          return Function.prototype.apply.apply(x, [d, arguments]);
        };
      }
    }
    function s() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function a(d) {
      return d === "debug" && (d = "log"), typeof console === n ? !1 : d === "trace" && r ? s : console[d] !== void 0 ? o(console, d) : console.log !== void 0 ? o(console, "log") : e;
    }
    function c(d, _) {
      for (var x = 0; x < i.length; x++) {
        var m = i[x];
        this[m] = x < d ? e : this.methodFactory(m, d, _);
      }
      this.log = this.debug;
    }
    function u(d, _, x) {
      return function() {
        typeof console !== n && (c.call(this, _, x), this[d].apply(this, arguments));
      };
    }
    function l(d, _, x) {
      return a(d) || u.apply(this, arguments);
    }
    function p(d, _, x) {
      var m = this, D;
      _ = _ ?? "WARN";
      var Z = "loglevel";
      typeof d == "string" ? Z += ":" + d : typeof d == "symbol" && (Z = void 0);
      function W(S) {
        var ee = (i[S] || "silent").toUpperCase();
        if (!(typeof window === n || !Z)) {
          try {
            window.localStorage[Z] = ee;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Z) + "=" + ee + ";";
          } catch {
          }
        }
      }
      function y() {
        var S;
        if (!(typeof window === n || !Z)) {
          try {
            S = window.localStorage[Z];
          } catch {
          }
          if (typeof S === n)
            try {
              var ee = window.document.cookie, vn = ee.indexOf(
                encodeURIComponent(Z) + "="
              );
              vn !== -1 && (S = /^([^;]+)/.exec(ee.slice(vn))[1]);
            } catch {
            }
          return m.levels[S] === void 0 && (S = void 0), S;
        }
      }
      function K() {
        if (!(typeof window === n || !Z)) {
          try {
            window.localStorage.removeItem(Z);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Z) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      m.name = d, m.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, m.methodFactory = x || l, m.getLevel = function() {
        return D;
      }, m.setLevel = function(S, ee) {
        if (typeof S == "string" && m.levels[S.toUpperCase()] !== void 0 && (S = m.levels[S.toUpperCase()]), typeof S == "number" && S >= 0 && S <= m.levels.SILENT) {
          if (D = S, ee !== !1 && W(S), c.call(m, S, d), typeof console === n && S < m.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + S;
      }, m.setDefaultLevel = function(S) {
        _ = S, y() || m.setLevel(S, !1);
      }, m.resetLevel = function() {
        m.setLevel(_, !1), K();
      }, m.enableAll = function(S) {
        m.setLevel(m.levels.TRACE, S);
      }, m.disableAll = function(S) {
        m.setLevel(m.levels.SILENT, S);
      };
      var q = y();
      q == null && (q = _), m.setLevel(q, !1);
    }
    var f = new p(), h = {};
    f.getLogger = function(d) {
      if (typeof d != "symbol" && typeof d != "string" || d === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var _ = h[d];
      return _ || (_ = h[d] = new p(
        d,
        f.getLevel(),
        f.methodFactory
      )), _;
    };
    var g = typeof window !== n ? window.log : void 0;
    return f.noConflict = function() {
      return typeof window !== n && window.log === f && (window.log = g), f;
    }, f.getLoggers = function() {
      return h;
    }, f.default = f, f;
  });
})(Yr);
const J = Yr.exports, Ss = (t) => t.incomingMessageSubject.pipe(
  ze((e) => {
    "eventType" in e ? (J.debug(
      ` message lifecycle event
${JSON.stringify(e, null, 2)}`
    ), t.messageLifeCycleEventSubject.next(e)) : (J.debug(` wallet response
${JSON.stringify(e, null, 2)}`), t.responseSubject.next(e));
  })
), Ts = (t) => t.dispatchEventSubject.pipe(
  ze(({ event: e, payload: n }) => {
    J.debug(` wallet request
${JSON.stringify(n, null, 2)}`), window.dispatchEvent(
      new CustomEvent(e, {
        detail: n
      })
    );
  })
), Os = (t) => {
  const e = new rt();
  return e.add(Ts(t).subscribe()), e.add(xs(t).subscribe()), e.add(Ss(t).subscribe()), e;
}, Es = (t) => {
  const e = (n) => {
    const r = n.detail;
    t.incomingMessageSubject.next(r);
  };
  return addEventListener(Yt.incomingMessage, e), { destroy: () => {
    removeEventListener(Yt.incomingMessage, e);
  } };
}, As = (t = _s()) => {
  const e = Os(t), n = Es(t);
  return { destroy: () => {
    n.destroy(), e.unsubscribe();
  }, subjects: t };
};
function Dt(t, e, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(s) {
      s(o);
    });
  }
  return new (n || (n = Promise))(function(o, s) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (p) {
        s(p);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (p) {
        s(p);
      }
    }
    function u(l) {
      l.done ? o(l.value) : i(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function qt(t, e) {
  var n = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, r, i, o, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, i && (o = u[0] & 2 ? i.return : u[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, u[1])).done)
          return o;
        switch (i = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, i = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (o = n.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < o[1]) {
              n.label = o[1], o = u;
              break;
            }
            if (o && n.label < o[2]) {
              n.label = o[2], n.ops.push(u);
              break;
            }
            o[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], i = 0;
      } finally {
        r = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function gt(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), i, o = [], s;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; )
      o.push(i.value);
  } catch (a) {
    s = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (s)
        throw s.error;
    }
  }
  return o;
}
function Ne(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, o; r < i; r++)
      (o || !(r in e)) && (o || (o = Array.prototype.slice.call(e, 0, r)), o[r] = e[r]);
  return t.concat(o || Array.prototype.slice.call(e));
}
var ks = {
  withStackTrace: !1
}, Jr = function(t, e, n) {
  n === void 0 && (n = ks);
  var r = e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, i = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: t,
    stack: i
  };
}, he = function() {
  function t(e) {
    this._promise = e;
  }
  return t.fromSafePromise = function(e) {
    var n = e.then(function(r) {
      return new ke(r);
    });
    return new t(n);
  }, t.fromPromise = function(e, n) {
    var r = e.then(function(i) {
      return new ke(i);
    }).catch(function(i) {
      return new Re(n(i));
    });
    return new t(r);
  }, t.combine = function(e) {
    return Ps(e);
  }, t.combineWithAllErrors = function(e) {
    return Cs(e);
  }, t.prototype.map = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return Dt(n, void 0, void 0, function() {
        var i;
        return qt(this, function(o) {
          switch (o.label) {
            case 0:
              return r.isErr() ? [2, new Re(r.error)] : (i = ke.bind, [4, e(r.value)]);
            case 1:
              return [2, new (i.apply(ke, [void 0, o.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.mapErr = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return Dt(n, void 0, void 0, function() {
        var i;
        return qt(this, function(o) {
          switch (o.label) {
            case 0:
              return r.isOk() ? [2, new ke(r.value)] : (i = Re.bind, [4, e(r.error)]);
            case 1:
              return [2, new (i.apply(Re, [void 0, o.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.andThen = function(e) {
    return new t(this._promise.then(function(n) {
      if (n.isErr())
        return new Re(n.error);
      var r = e(n.value);
      return r instanceof t ? r._promise : r;
    }));
  }, t.prototype.orElse = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return Dt(n, void 0, void 0, function() {
        return qt(this, function(i) {
          return r.isErr() ? [2, e(r.error)] : [2, new ke(r.value)];
        });
      });
    }));
  }, t.prototype.match = function(e, n) {
    return this._promise.then(function(r) {
      return r.match(e, n);
    });
  }, t.prototype.unwrapOr = function(e) {
    return this._promise.then(function(n) {
      return n.unwrapOr(e);
    });
  }, t.prototype.then = function(e, n) {
    return this._promise.then(e, n);
  }, t;
}(), In = function(t) {
  return new he(Promise.resolve(new Re(t)));
};
he.fromPromise;
he.fromSafePromise;
var Is = function(t) {
  return function(e) {
    return Ne(Ne([], gt(e), !1), [t], !1);
  };
}, Gr = function(t) {
  return t.reduce(function(e, n) {
    return e.isOk() ? n.isErr() ? ie(n.error) : e.map(Is(n.value)) : e;
  }, re([]));
}, Ps = function(t) {
  return he.fromSafePromise(Promise.all(t)).andThen(Gr);
}, Qr = function(t) {
  return t.reduce(function(e, n) {
    return n.isErr() ? e.isErr() ? ie(Ne(Ne([], gt(e.error), !1), [n.error], !1)) : ie([n.error]) : e.isErr() ? e : re(Ne(Ne([], gt(e.value), !1), [n.value], !1));
  }, re([]));
}, Cs = function(t) {
  return he.fromSafePromise(Promise.all(t)).andThen(Qr);
}, Jt;
(function(t) {
  function e(i, o) {
    return function() {
      for (var s = [], a = 0; a < arguments.length; a++)
        s[a] = arguments[a];
      try {
        var c = i.apply(void 0, Ne([], gt(s), !1));
        return re(c);
      } catch (u) {
        return ie(o ? o(u) : u);
      }
    };
  }
  t.fromThrowable = e;
  function n(i) {
    return Gr(i);
  }
  t.combine = n;
  function r(i) {
    return Qr(i);
  }
  t.combineWithAllErrors = r;
})(Jt || (Jt = {}));
var re = function(t) {
  return new ke(t);
}, ie = function(t) {
  return new Re(t);
}, ke = function() {
  function t(e) {
    this.value = e;
  }
  return t.prototype.isOk = function() {
    return !0;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return re(e(this.value));
  }, t.prototype.mapErr = function(e) {
    return re(this.value);
  }, t.prototype.andThen = function(e) {
    return e(this.value);
  }, t.prototype.orElse = function(e) {
    return re(this.value);
  }, t.prototype.asyncAndThen = function(e) {
    return e(this.value);
  }, t.prototype.asyncMap = function(e) {
    return he.fromSafePromise(e(this.value));
  }, t.prototype.unwrapOr = function(e) {
    return this.value;
  }, t.prototype.match = function(e, n) {
    return e(this.value);
  }, t.prototype._unsafeUnwrap = function(e) {
    return this.value;
  }, t.prototype._unsafeUnwrapErr = function(e) {
    throw Jr("Called `_unsafeUnwrapErr` on an Ok", this, e);
  }, t;
}(), Re = function() {
  function t(e) {
    this.error = e;
  }
  return t.prototype.isOk = function() {
    return !1;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return ie(this.error);
  }, t.prototype.mapErr = function(e) {
    return ie(e(this.error));
  }, t.prototype.andThen = function(e) {
    return ie(this.error);
  }, t.prototype.orElse = function(e) {
    return e(this.error);
  }, t.prototype.asyncAndThen = function(e) {
    return In(this.error);
  }, t.prototype.asyncMap = function(e) {
    return In(this.error);
  }, t.prototype.unwrapOr = function(e) {
    return e;
  }, t.prototype.match = function(e, n) {
    return n(this.error);
  }, t.prototype._unsafeUnwrap = function(e) {
    throw Jr("Called `_unsafeUnwrap` on an Err", this, e);
  }, t.prototype._unsafeUnwrapErr = function(e) {
    return this.error;
  }, t;
}();
Jt.fromThrowable;
const te = {
  extensionDetectionTime: 100,
  defaultNumberOfAccountsQuantity: 1,
  defaultNumberOfAccountsQuantifier: "atLeast",
  logLevel: "info"
}, Rs = (t) => t, Le = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee"
}, $s = (/* @__PURE__ */ new Map()).set(Le.missingExtension, "extension could not be found").set(Le.rejectedByUser, "user rejected request").set(Le.canceledByUser, "user has canceled the request"), wt = (t, e, n) => ({
  error: t,
  interactionId: e,
  message: n || $s.get(t) || ""
}), js = (t) => he.fromPromise(fs(t), Rs).andThen(
  (e) => e
), Ns = (t, e) => t.messageLifeCycleEventSubject.pipe(
  at((n) => n.interactionId === e)
), Ls = (t) => (e) => (n) => {
  const r = new ye();
  e.requestControl && e.requestControl({
    cancelRequest: () => (J.debug(
      ` wallet request canceled
${JSON.stringify(
        n,
        null,
        2
      )}`
    ), r.next())
  });
  const i = r.asObservable().pipe(
    st(
      () => ie(wt(Le.canceledByUser, n.interactionId))
    )
  ), o = t.responseSubject.pipe(
    at((h) => h.interactionId === n.interactionId),
    st(
      (h) => "items" in h ? re(h) : ie(h)
    )
  ), s = Lt(
    o,
    i
  ).pipe(kn()), a = Ns(t, n.interactionId).pipe(
    ze((h) => {
      e.eventCallback && e.eventCallback(h.eventType);
    }),
    ws(o),
    Hr()
  ), c = a.subscribe(), u = ms(te.extensionDetectionTime).pipe(
    st(
      () => ie(wt(Le.missingExtension, n.interactionId))
    )
  ), l = Lt(
    u,
    a
  ).pipe(
    kn(),
    at((h) => !("eventType" in h))
  ), p = ls(!0).pipe(
    ze(() => {
      t.outgoingMessageSubject.next(n);
    }),
    at(() => !1)
  ), f = Lt(
    s,
    l,
    p
  ).pipe(
    ze(() => {
      c.unsubscribe();
    })
  );
  return js(f);
};
var P;
(function(t) {
  t.assertEqual = (i) => i;
  function e(i) {
  }
  t.assertIs = e;
  function n(i) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (i) => {
    const o = {};
    for (const s of i)
      o[s] = s;
    return o;
  }, t.getValidEnumValues = (i) => {
    const o = t.objectKeys(i).filter((a) => typeof i[i[a]] != "number"), s = {};
    for (const a of o)
      s[a] = i[a];
    return t.objectValues(s);
  }, t.objectValues = (i) => t.objectKeys(i).map(function(o) {
    return i[o];
  }), t.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const o = [];
    for (const s in i)
      Object.prototype.hasOwnProperty.call(i, s) && o.push(s);
    return o;
  }, t.find = (i, o) => {
    for (const s of i)
      if (o(s))
        return s;
  }, t.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, o = " | ") {
    return i.map((s) => typeof s == "string" ? `'${s}'` : s).join(o);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (i, o) => typeof o == "bigint" ? o.toString() : o;
})(P || (P = {}));
const b = P.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), $e = (t) => {
  switch (typeof t) {
    case "undefined":
      return b.undefined;
    case "string":
      return b.string;
    case "number":
      return isNaN(t) ? b.nan : b.number;
    case "boolean":
      return b.boolean;
    case "function":
      return b.function;
    case "bigint":
      return b.bigint;
    case "object":
      return Array.isArray(t) ? b.array : t === null ? b.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? b.promise : typeof Map < "u" && t instanceof Map ? b.map : typeof Set < "u" && t instanceof Set ? b.set : typeof Date < "u" && t instanceof Date ? b.date : b.object;
    default:
      return b.unknown;
  }
}, v = P.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of"
]);
class ut extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const n = e || function(o) {
      return o.message;
    }, r = { _errors: [] }, i = (o) => {
      for (const s of o.issues)
        if (s.code === "invalid_union")
          s.unionErrors.map(i);
        else if (s.code === "invalid_return_type")
          i(s.returnTypeError);
        else if (s.code === "invalid_arguments")
          i(s.argumentsError);
        else if (s.path.length === 0)
          r._errors.push(n(s));
        else {
          let a = r, c = 0;
          for (; c < s.path.length; ) {
            const u = s.path[c];
            c === s.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(s))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return i(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, P.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(e(i))) : r.push(e(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
ut.create = (t) => new ut(t);
const Xr = (t, e) => {
  let n;
  switch (t.code) {
    case v.invalid_type:
      t.received === b.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case v.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, P.jsonStringifyReplacer)}`;
      break;
    case v.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${P.joinValues(t.keys, ", ")}`;
      break;
    case v.invalid_union:
      n = "Invalid input";
      break;
    case v.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${P.joinValues(t.options)}`;
      break;
    case v.invalid_enum_value:
      n = `Invalid enum value. Expected ${P.joinValues(t.options)}, received '${t.received}'`;
      break;
    case v.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case v.invalid_return_type:
      n = "Invalid function return type";
      break;
    case v.invalid_date:
      n = "Invalid date";
      break;
    case v.invalid_string:
      typeof t.validation == "object" ? "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : P.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case v.too_small:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be greater than ${t.inclusive ? "or equal to " : ""}${t.minimum}` : t.type === "date" ? n = `Date must be greater than ${t.inclusive ? "or equal to " : ""}${new Date(t.minimum)}` : n = "Invalid input";
      break;
    case v.too_big:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be less than ${t.inclusive ? "or equal to " : ""}${t.maximum}` : t.type === "date" ? n = `Date must be smaller than ${t.inclusive ? "or equal to " : ""}${new Date(t.maximum)}` : n = "Invalid input";
      break;
    case v.custom:
      n = "Invalid input";
      break;
    case v.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case v.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    default:
      n = e.defaultError, P.assertNever(t);
  }
  return { message: n };
};
let Zs = Xr;
function Ds() {
  return Zs;
}
const qs = (t) => {
  const { data: e, path: n, errorMaps: r, issueData: i } = t, o = [...n, ...i.path || []], s = {
    ...i,
    path: o
  };
  let a = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(s, { data: e, defaultError: a }).message;
  return {
    ...i,
    path: o,
    message: i.message || a
  };
};
function w(t, e) {
  const n = qs({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      Ds(),
      Xr
    ].filter((r) => !!r)
  });
  t.common.issues.push(n);
}
class H {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return E;
      i.status === "dirty" && e.dirty(), r.push(i.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const i of n)
      r.push({
        key: await i.key,
        value: await i.value
      });
    return H.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const i of n) {
      const { key: o, value: s } = i;
      if (o.status === "aborted" || s.status === "aborted")
        return E;
      o.status === "dirty" && e.dirty(), s.status === "dirty" && e.dirty(), (typeof s.value < "u" || i.alwaysSet) && (r[o.value] = s.value);
    }
    return { status: e.value, value: r };
  }
}
const E = Object.freeze({
  status: "aborted"
}), Y = (t) => ({ status: "valid", value: t }), Pn = (t) => t.status === "aborted", Cn = (t) => t.status === "dirty", Gt = (t) => t.status === "valid", Rn = (t) => typeof Promise !== void 0 && t instanceof Promise;
var A;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(A || (A = {}));
class xe {
  constructor(e, n, r, i) {
    this.parent = e, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._path.concat(this._key);
  }
}
const $n = (t, e) => {
  if (Gt(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: !1, error: new ut(t.common.issues) };
};
function k(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: r, description: i } = t;
  if (e && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: i } : { errorMap: (o, s) => o.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: r ?? s.defaultError } : { message: n ?? s.defaultError }, description: i };
}
class R {
  constructor(e) {
    this.spa = this.safeParseAsync, this.superRefine = this._refinement, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return $e(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: $e(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new H(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: $e(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Rn(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: $e(e)
    }, o = this._parseSync({ data: e, path: i.path, parent: i });
    return $n(i, o);
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: $e(e)
    }, i = this._parse({ data: e, path: [], parent: r }), o = await (Rn(i) ? i : Promise.resolve(i));
    return $n(r, o);
  }
  refine(e, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, o) => {
      const s = e(i), a = () => o.addIssue({
        code: v.custom,
        ...r(i)
      });
      return typeof Promise < "u" && s instanceof Promise ? s.then((c) => c ? !0 : (a(), !1)) : s ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, i) => e(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(e) {
    return new tt({
      schema: this,
      typeName: T.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  optional() {
    return le.create(this);
  }
  nullable() {
    return nt.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return de.create(this);
  }
  promise() {
    return Tt.create(this);
  }
  or(e) {
    return xt.create([this, e]);
  }
  and(e) {
    return St.create(this, e);
  }
  transform(e) {
    return new tt({
      schema: this,
      typeName: T.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new ni({
      innerType: this,
      defaultValue: n,
      typeName: T.ZodDefault
    });
  }
  brand() {
    return new Bs({
      typeName: T.ZodBranded,
      type: this,
      ...k(void 0)
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Us = /^c[^\s-]{8,}$/i, Ws = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Ms = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class Xe extends R {
  constructor() {
    super(...arguments), this._regex = (e, n, r) => this.refinement((i) => e.test(i), {
      validation: n,
      code: v.invalid_string,
      ...A.errToObj(r)
    }), this.nonempty = (e) => this.min(1, A.errToObj(e)), this.trim = () => new Xe({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(e) {
    if (this._getType(e) !== b.string) {
      const i = this._getOrReturnCtx(e);
      return w(
        i,
        {
          code: v.invalid_type,
          expected: b.string,
          received: i.parsedType
        }
      ), E;
    }
    const n = new H();
    let r;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (r = this._getOrReturnCtx(e, r), w(r, {
          code: v.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (r = this._getOrReturnCtx(e, r), w(r, {
          code: v.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), n.dirty());
      else if (i.kind === "email")
        Ms.test(e.data) || (r = this._getOrReturnCtx(e, r), w(r, {
          validation: "email",
          code: v.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        Ws.test(e.data) || (r = this._getOrReturnCtx(e, r), w(r, {
          validation: "uuid",
          code: v.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        Us.test(e.data) || (r = this._getOrReturnCtx(e, r), w(r, {
          validation: "cuid",
          code: v.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          r = this._getOrReturnCtx(e, r), w(r, {
            validation: "url",
            code: v.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (r = this._getOrReturnCtx(e, r), w(r, {
          validation: "regex",
          code: v.invalid_string,
          message: i.message
        }), n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (r = this._getOrReturnCtx(e, r), w(r, {
          code: v.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (r = this._getOrReturnCtx(e, r), w(r, {
          code: v.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), n.dirty()) : P.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _addCheck(e) {
    return new Xe({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...A.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...A.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...A.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...A.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...A.errToObj(n)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...A.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...A.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...A.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...A.errToObj(n)
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
Xe.create = (t) => new Xe({
  checks: [],
  typeName: T.ZodString,
  ...k(t)
});
function Fs(t, e) {
  const n = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, i = n > r ? n : r, o = parseInt(t.toFixed(i).replace(".", "")), s = parseInt(e.toFixed(i).replace(".", ""));
  return o % s / Math.pow(10, i);
}
class et extends R {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._getType(e) !== b.number) {
      const i = this._getOrReturnCtx(e);
      return w(i, {
        code: v.invalid_type,
        expected: b.number,
        received: i.parsedType
      }), E;
    }
    let n;
    const r = new H();
    for (const i of this._def.checks)
      i.kind === "int" ? P.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), w(n, {
        code: v.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), r.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), w(n, {
        code: v.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), w(n, {
        code: v.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), r.dirty()) : i.kind === "multipleOf" ? Fs(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), w(n, {
        code: v.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), r.dirty()) : P.assertNever(i);
    return { status: r.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, A.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, A.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, A.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, A.toString(n));
  }
  setLimit(e, n, r, i) {
    return new et({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: A.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new et({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: A.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: A.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: A.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: A.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: A.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: A.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int");
  }
}
et.create = (t) => new et({
  checks: [],
  typeName: T.ZodNumber,
  ...k(t)
});
class jn extends R {
  _parse(e) {
    if (this._getType(e) !== b.bigint) {
      const n = this._getOrReturnCtx(e);
      return w(n, {
        code: v.invalid_type,
        expected: b.bigint,
        received: n.parsedType
      }), E;
    }
    return Y(e.data);
  }
}
jn.create = (t) => new jn({
  typeName: T.ZodBigInt,
  ...k(t)
});
class Qt extends R {
  _parse(e) {
    if (this._getType(e) !== b.boolean) {
      const n = this._getOrReturnCtx(e);
      return w(n, {
        code: v.invalid_type,
        expected: b.boolean,
        received: n.parsedType
      }), E;
    }
    return Y(e.data);
  }
}
Qt.create = (t) => new Qt({
  typeName: T.ZodBoolean,
  ...k(t)
});
class _t extends R {
  _parse(e) {
    if (this._getType(e) !== b.date) {
      const i = this._getOrReturnCtx(e);
      return w(i, {
        code: v.invalid_type,
        expected: b.date,
        received: i.parsedType
      }), E;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return w(i, {
        code: v.invalid_date
      }), E;
    }
    const n = new H();
    let r;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (r = this._getOrReturnCtx(e, r), w(r, {
        code: v.too_small,
        message: i.message,
        inclusive: !0,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (r = this._getOrReturnCtx(e, r), w(r, {
        code: v.too_big,
        message: i.message,
        inclusive: !0,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : P.assertNever(i);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new _t({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: A.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: A.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
_t.create = (t) => new _t({
  checks: [],
  typeName: T.ZodDate,
  ...k(t)
});
class Nn extends R {
  _parse(e) {
    if (this._getType(e) !== b.undefined) {
      const n = this._getOrReturnCtx(e);
      return w(n, {
        code: v.invalid_type,
        expected: b.undefined,
        received: n.parsedType
      }), E;
    }
    return Y(e.data);
  }
}
Nn.create = (t) => new Nn({
  typeName: T.ZodUndefined,
  ...k(t)
});
class Ln extends R {
  _parse(e) {
    if (this._getType(e) !== b.null) {
      const n = this._getOrReturnCtx(e);
      return w(n, {
        code: v.invalid_type,
        expected: b.null,
        received: n.parsedType
      }), E;
    }
    return Y(e.data);
  }
}
Ln.create = (t) => new Ln({
  typeName: T.ZodNull,
  ...k(t)
});
class Zn extends R {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return Y(e.data);
  }
}
Zn.create = (t) => new Zn({
  typeName: T.ZodAny,
  ...k(t)
});
class Dn extends R {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return Y(e.data);
  }
}
Dn.create = (t) => new Dn({
  typeName: T.ZodUnknown,
  ...k(t)
});
class Se extends R {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return w(n, {
      code: v.invalid_type,
      expected: b.never,
      received: n.parsedType
    }), E;
  }
}
Se.create = (t) => new Se({
  typeName: T.ZodNever,
  ...k(t)
});
class qn extends R {
  _parse(e) {
    if (this._getType(e) !== b.undefined) {
      const n = this._getOrReturnCtx(e);
      return w(n, {
        code: v.invalid_type,
        expected: b.void,
        received: n.parsedType
      }), E;
    }
    return Y(e.data);
  }
}
qn.create = (t) => new qn({
  typeName: T.ZodVoid,
  ...k(t)
});
class de extends R {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e), i = this._def;
    if (n.parsedType !== b.array)
      return w(n, {
        code: v.invalid_type,
        expected: b.array,
        received: n.parsedType
      }), E;
    if (i.minLength !== null && n.data.length < i.minLength.value && (w(n, {
      code: v.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (w(n, {
      code: v.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all(n.data.map((s, a) => i.type._parseAsync(new xe(n, s, n.path, a)))).then((s) => H.mergeArray(r, s));
    const o = n.data.map((s, a) => i.type._parseSync(new xe(n, s, n.path, a)));
    return H.mergeArray(r, o);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new de({
      ...this._def,
      minLength: { value: e, message: A.toString(n) }
    });
  }
  max(e, n) {
    return new de({
      ...this._def,
      maxLength: { value: e, message: A.toString(n) }
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
de.create = (t, e) => new de({
  type: t,
  minLength: null,
  maxLength: null,
  typeName: T.ZodArray,
  ...k(e)
});
var Xt;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
  });
})(Xt || (Xt = {}));
const Un = (t) => (e) => new j({
  ...t,
  shape: () => ({
    ...t.shape(),
    ...e
  })
});
function Me(t) {
  if (t instanceof j) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = le.create(Me(r));
    }
    return new j({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof de ? de.create(Me(t.element)) : t instanceof le ? le.create(Me(t.unwrap())) : t instanceof nt ? nt.create(Me(t.unwrap())) : t instanceof Ze ? Ze.create(t.items.map((e) => Me(e))) : t;
}
class j extends R {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = Un(this._def), this.extend = Un(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = P.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== b.object) {
      const c = this._getOrReturnCtx(e);
      return w(c, {
        code: v.invalid_type,
        expected: b.object,
        received: c.parsedType
      }), E;
    }
    const { status: n, ctx: r } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Se && this._def.unknownKeys === "strip"))
      for (const c in r.data)
        o.includes(c) || s.push(c);
    const a = [];
    for (const c of o) {
      const u = i[c], l = r.data[c];
      a.push({
        key: { status: "valid", value: c },
        value: u._parse(new xe(r, l, r.path, c)),
        alwaysSet: c in r.data
      });
    }
    if (this._def.catchall instanceof Se) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of s)
          a.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: r.data[u] }
          });
      else if (c === "strict")
        s.length > 0 && (w(r, {
          code: v.unrecognized_keys,
          keys: s
        }), n.dirty());
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of s) {
        const l = r.data[u];
        a.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new xe(r, l, r.path, u)
          ),
          alwaysSet: u in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of a) {
        const l = await u.key;
        c.push({
          key: l,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => H.mergeObjectSync(n, c)) : H.mergeObjectSync(n, a);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return A.errToObj, new j({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var i, o, s, a;
          const c = (s = (o = (i = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(i, n, r).message) !== null && s !== void 0 ? s : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = A.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new j({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new j({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  merge(e) {
    return new j({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => Xt.mergeShapes(this._def.shape(), e._def.shape()),
      typeName: T.ZodObject
    });
  }
  catchall(e) {
    return new j({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return P.objectKeys(e).map((r) => {
      this.shape[r] && (n[r] = this.shape[r]);
    }), new j({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return P.objectKeys(this.shape).map((r) => {
      P.objectKeys(e).indexOf(r) === -1 && (n[r] = this.shape[r]);
    }), new j({
      ...this._def,
      shape: () => n
    });
  }
  deepPartial() {
    return Me(this);
  }
  partial(e) {
    const n = {};
    if (e)
      return P.objectKeys(this.shape).map((r) => {
        P.objectKeys(e).indexOf(r) === -1 ? n[r] = this.shape[r] : n[r] = this.shape[r].optional();
      }), new j({
        ...this._def,
        shape: () => n
      });
    for (const r in this.shape) {
      const i = this.shape[r];
      n[r] = i.optional();
    }
    return new j({
      ...this._def,
      shape: () => n
    });
  }
  required() {
    const e = {};
    for (const n in this.shape) {
      let r = this.shape[n];
      for (; r instanceof le; )
        r = r._def.innerType;
      e[n] = r;
    }
    return new j({
      ...this._def,
      shape: () => e
    });
  }
  keyof() {
    return ei(P.objectKeys(this.shape));
  }
}
j.create = (t, e) => new j({
  shape: () => t,
  unknownKeys: "strip",
  catchall: Se.create(),
  typeName: T.ZodObject,
  ...k(e)
});
j.strictCreate = (t, e) => new j({
  shape: () => t,
  unknownKeys: "strict",
  catchall: Se.create(),
  typeName: T.ZodObject,
  ...k(e)
});
j.lazycreate = (t, e) => new j({
  shape: t,
  unknownKeys: "strip",
  catchall: Se.create(),
  typeName: T.ZodObject,
  ...k(e)
});
class xt extends R {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = this._def.options;
    function i(o) {
      for (const a of o)
        if (a.result.status === "valid")
          return a.result;
      for (const a of o)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((a) => new ut(a.ctx.common.issues));
      return w(n, {
        code: v.invalid_union,
        unionErrors: s
      }), E;
    }
    if (n.common.async)
      return Promise.all(r.map(async (o) => {
        const s = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await o._parseAsync({
            data: n.data,
            path: n.path,
            parent: s
          }),
          ctx: s
        };
      })).then(i);
    {
      let o;
      const s = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !o && (o = { result: l, ctx: u }), u.common.issues.length && s.push(u.common.issues);
      }
      if (o)
        return n.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((c) => new ut(c));
      return w(n, {
        code: v.invalid_union,
        unionErrors: a
      }), E;
    }
  }
  get options() {
    return this._def.options;
  }
}
xt.create = (t, e) => new xt({
  options: t,
  typeName: T.ZodUnion,
  ...k(e)
});
function en(t, e) {
  const n = $e(t), r = $e(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === b.object && r === b.object) {
    const i = P.objectKeys(e), o = P.objectKeys(t).filter((a) => i.indexOf(a) !== -1), s = { ...t, ...e };
    for (const a of o) {
      const c = en(t[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      s[a] = c.data;
    }
    return { valid: !0, data: s };
  } else if (n === b.array && r === b.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const i = [];
    for (let o = 0; o < t.length; o++) {
      const s = t[o], a = e[o], c = en(s, a);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else
    return n === b.date && r === b.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class St extends R {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), i = (o, s) => {
      if (Pn(o) || Pn(s))
        return E;
      const a = en(o.value, s.value);
      return a.valid ? ((Cn(o) || Cn(s)) && n.dirty(), { status: n.value, value: a.data }) : (w(r, {
        code: v.invalid_intersection_types
      }), E);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([o, s]) => i(o, s)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
St.create = (t, e, n) => new St({
  left: t,
  right: e,
  typeName: T.ZodIntersection,
  ...k(n)
});
class Ze extends R {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== b.array)
      return w(r, {
        code: v.invalid_type,
        expected: b.array,
        received: r.parsedType
      }), E;
    if (r.data.length < this._def.items.length)
      return w(r, {
        code: v.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        type: "array"
      }), E;
    !this._def.rest && r.data.length > this._def.items.length && (w(r, {
      code: v.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      type: "array"
    }), n.dirty());
    const i = r.data.map((o, s) => {
      const a = this._def.items[s] || this._def.rest;
      return a ? a._parse(new xe(r, o, r.path, s)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(i).then((o) => H.mergeArray(n, o)) : H.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Ze({
      ...this._def,
      rest: e
    });
  }
}
Ze.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Ze({
    items: t,
    typeName: T.ZodTuple,
    rest: null,
    ...k(e)
  });
};
class Wn extends R {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== b.map)
      return w(r, {
        code: v.invalid_type,
        expected: b.map,
        received: r.parsedType
      }), E;
    const i = this._def.keyType, o = this._def.valueType, s = [...r.data.entries()].map(([a, c], u) => ({
      key: i._parse(new xe(r, a, r.path, [u, "key"])),
      value: o._parse(new xe(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of s) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return E;
          (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of s) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return E;
        (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
      }
      return { status: n.value, value: a };
    }
  }
}
Wn.create = (t, e, n) => new Wn({
  valueType: e,
  keyType: t,
  typeName: T.ZodMap,
  ...k(n)
});
class ct extends R {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== b.set)
      return w(r, {
        code: v.invalid_type,
        expected: b.set,
        received: r.parsedType
      }), E;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (w(r, {
      code: v.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (w(r, {
      code: v.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      message: i.maxSize.message
    }), n.dirty());
    const o = this._def.valueType;
    function s(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return E;
        l.status === "dirty" && n.dirty(), u.add(l.value);
      }
      return { status: n.value, value: u };
    }
    const a = [...r.data.values()].map((c, u) => o._parse(new xe(r, c, r.path, u)));
    return r.common.async ? Promise.all(a).then((c) => s(c)) : s(a);
  }
  min(e, n) {
    return new ct({
      ...this._def,
      minSize: { value: e, message: A.toString(n) }
    });
  }
  max(e, n) {
    return new ct({
      ...this._def,
      maxSize: { value: e, message: A.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ct.create = (t, e) => new ct({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: T.ZodSet,
  ...k(e)
});
class Mn extends R {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Mn.create = (t, e) => new Mn({
  getter: t,
  typeName: T.ZodLazy,
  ...k(e)
});
class tn extends R {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return w(n, {
        code: v.invalid_literal,
        expected: this._def.value
      }), E;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
tn.create = (t, e) => new tn({
  value: t,
  typeName: T.ZodLiteral,
  ...k(e)
});
function ei(t, e) {
  return new ti({
    values: t,
    typeName: T.ZodEnum,
    ...k(e)
  });
}
class ti extends R {
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return w(n, {
        expected: P.joinValues(r),
        received: n.parsedType,
        code: v.invalid_type
      }), E;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return w(n, {
        received: n.data,
        code: v.invalid_enum_value,
        options: r
      }), E;
    }
    return Y(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
}
ti.create = ei;
class Fn extends R {
  _parse(e) {
    const n = P.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== b.string && r.parsedType !== b.number) {
      const i = P.objectValues(n);
      return w(r, {
        expected: P.joinValues(i),
        received: r.parsedType,
        code: v.invalid_type
      }), E;
    }
    if (n.indexOf(e.data) === -1) {
      const i = P.objectValues(n);
      return w(r, {
        received: r.data,
        code: v.invalid_enum_value,
        options: i
      }), E;
    }
    return Y(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
Fn.create = (t, e) => new Fn({
  values: t,
  typeName: T.ZodNativeEnum,
  ...k(e)
});
class Tt extends R {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== b.promise && n.common.async === !1)
      return w(n, {
        code: v.invalid_type,
        expected: b.promise,
        received: n.parsedType
      }), E;
    const r = n.parsedType === b.promise ? n.data : Promise.resolve(n.data);
    return Y(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Tt.create = (t, e) => new Tt({
  type: t,
  typeName: T.ZodPromise,
  ...k(e)
});
class tt extends R {
  innerType() {
    return this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), i = this._def.effect || null;
    if (i.type === "preprocess") {
      const s = i.transform(r.data);
      return r.common.async ? Promise.resolve(s).then((a) => this._def.schema._parseAsync({
        data: a,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: s,
        path: r.path,
        parent: r
      });
    }
    const o = {
      addIssue: (s) => {
        w(r, s), s.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (o.addIssue = o.addIssue.bind(o), i.type === "refinement") {
      const s = (a) => {
        const c = i.refinement(a, o);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? E : (a.status === "dirty" && n.dirty(), s(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? E : (a.status === "dirty" && n.dirty(), s(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Gt(s))
          return s;
        const a = i.transform(s.value, o);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => Gt(s) ? Promise.resolve(i.transform(s.value, o)).then((a) => ({ status: n.value, value: a })) : s);
    P.assertNever(i);
  }
}
tt.create = (t, e, n) => new tt({
  schema: t,
  typeName: T.ZodEffects,
  effect: e,
  ...k(n)
});
tt.createWithPreprocess = (t, e, n) => new tt({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: T.ZodEffects,
  ...k(n)
});
class le extends R {
  _parse(e) {
    return this._getType(e) === b.undefined ? Y(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
le.create = (t, e) => new le({
  innerType: t,
  typeName: T.ZodOptional,
  ...k(e)
});
class nt extends R {
  _parse(e) {
    return this._getType(e) === b.null ? Y(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
nt.create = (t, e) => new nt({
  innerType: t,
  typeName: T.ZodNullable,
  ...k(e)
});
class ni extends R {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === b.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ni.create = (t, e) => new le({
  innerType: t,
  typeName: T.ZodOptional,
  ...k(e)
});
class Bn extends R {
  _parse(e) {
    if (this._getType(e) !== b.nan) {
      const n = this._getOrReturnCtx(e);
      return w(n, {
        code: v.invalid_type,
        expected: b.nan,
        received: n.parsedType
      }), E;
    }
    return { status: "valid", value: e.data };
  }
}
Bn.create = (t) => new Bn({
  typeName: T.ZodNaN,
  ...k(t)
});
class Bs extends R {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
j.lazycreate;
var T;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded";
})(T || (T = {}));
const $ = Xe.create, Et = et.create, ri = Qt.create;
Se.create;
de.create;
const I = j.create;
j.strictCreate;
const z = xt.create;
St.create;
Ze.create;
const O = tn.create;
Tt.create;
le.create;
nt.create;
const qe = {
  oneTimeAccounts: O("oneTimeAccounts"),
  ongoingAccounts: O("ongoingAccounts"),
  oneTimePersonaData: O("oneTimePersonaData"),
  ongoingPersonaData: O("ongoingPersonaData"),
  auth: O("auth"),
  send: O("send")
}, zs = z([
  O("rejectedByUser"),
  O("wrongNetwork"),
  O("failedToPrepareTransaction"),
  O("failedToCompileTransaction"),
  O("failedToSignTransaction"),
  O("failedToSubmitTransaction"),
  O("failedToPollSubmittedTransaction"),
  O("failedToFindAccountWithEnoughFundsToLockFee"),
  O("submittedTransactionWasDuplicate"),
  O("submittedTransactionHasFailedTransactionStatus"),
  O("submittedTransactionHasRejectedTransactionStatus")
]), hn = I({
  address: $(),
  label: $(),
  appearanceId: Et()
}), ii = I({
  account: hn,
  challenge: $(),
  signature: $()
}), pn = I({
  identityAddress: $(),
  label: $()
}), oi = I({
  field: $(),
  value: $()
});
z([
  O("exactly"),
  O("atLeast")
]);
const si = I({
  quantifier: z([O("exactly"), O("atLeast")]),
  quantity: Et()
}), Ks = I({
  networkId: Et(),
  dAppDefinitionAddress: $()
}), ai = I({
  requiresProofOfOwnership: ri(),
  numberOfAccounts: si
}), Vs = I({
  accounts: ii.array()
}), Hs = I({
  accounts: hn.array()
}), ui = z([
  Vs,
  Hs
]), Ys = I({
  requiresProofOfOwnership: ri(),
  numberOfAccounts: si
}), Js = I({
  accounts: ii.array()
}), Gs = I({
  accounts: hn.array()
}), Qs = z([
  Js,
  Gs
]), ci = I({
  fields: $().array()
}), li = I({
  fields: oi.array()
}), Xs = I({
  fields: $().array()
}), ea = I({
  fields: oi.array()
}), ta = I({
  discriminator: O("usePersona"),
  identityAddress: $()
}), na = I({
  discriminator: O("usePersona"),
  persona: pn
}), ra = I({
  discriminator: O("login"),
  challenge: $().optional()
}), ia = I({
  discriminator: O("loginWithoutChallenge"),
  persona: pn
}), oa = I({
  discriminator: O("loginWithChallenge"),
  persona: pn,
  challenge: $(),
  publicKey: $(),
  signature: $()
}), sa = z([
  ia,
  oa
]), aa = z([
  ta,
  ra
]), ua = z([
  na,
  sa
]), ca = I({
  transactionManifest: $(),
  version: Et(),
  blobs: $().array().optional(),
  message: $().optional()
}), la = I({
  transactionIntentHash: $()
}), fa = I({
  discriminator: O("unauthorizedRequest"),
  oneTimeAccounts: ai.optional(),
  oneTimePersonaData: ci.optional()
}), da = I({
  discriminator: O("authorizedRequest"),
  auth: aa,
  oneTimeAccounts: ai.optional(),
  ongoingAccounts: Ys.optional(),
  oneTimePersonaData: ci.optional(),
  ongoingPersonaData: Xs.optional()
}), ha = z([
  fa,
  da
]), pa = I({
  discriminator: O("transaction"),
  send: ca
}), ma = z([
  ha,
  pa
]), va = I({
  interactionId: $(),
  items: ma,
  metadata: Ks
}), ya = I({
  discriminator: O("unauthorizedRequest"),
  oneTimeAccounts: ui.optional(),
  oneTimePersonaData: li.optional()
}), ba = I({
  discriminator: O("authorizedRequest"),
  auth: ua,
  oneTimeAccounts: ui.optional(),
  ongoingAccounts: Qs.optional(),
  oneTimePersonaData: li.optional(),
  ongoingPersonaData: ea.optional()
}), ga = z([
  ya,
  ba
]), wa = I({
  discriminator: O("transaction"),
  send: la
}), _a = z([
  ga,
  wa
]), xa = I({
  discriminator: O("success"),
  interactionId: $(),
  items: _a
}), Sa = I({
  discriminator: O("failure"),
  interactionId: $(),
  error: zs,
  message: $().optional()
}), Ta = z([
  xa,
  Sa
]), zn = (t) => he.fromPromise(
  va.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr((e) => (J.error(" invalid wallet request"), J.debug(JSON.stringify(t, null, 2)), J.debug(JSON.stringify(e, null, 2)), wt(
  Le.walletRequestValidation,
  t.interactionId
))), Kn = (t) => he.fromPromise(
  Ta.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr(() => (J.error(" invalid wallet response"), wt(
  Le.walletRequestValidation,
  t.interactionId
))), Vn = (t) => {
  const { discriminator: e, ...n } = t;
  return Object.entries(n).reduce((r, [i, o]) => {
    switch (i) {
      case qe.auth.value: {
        const { discriminator: s, ...a } = o;
        if (s === "usePersona")
          return { ...r, persona: a.persona };
        if (s === "loginWithChallenge") {
          const { persona: c, ...u } = a;
          return { ...r, persona: c, signedChallenge: u };
        } else
          return { ...r, persona: a.persona };
      }
      case qe.oneTimeAccounts.value:
        return { ...r, oneTimeAccounts: o.accounts };
      case qe.ongoingAccounts.value:
        return { ...r, ongoingAccounts: o.accounts };
      case qe.oneTimePersonaData.value:
        return { ...r, oneTimePersonaData: o.fields };
      case qe.ongoingPersonaData.value:
        return { ...r, ongoingPersonaData: o.fields };
      case qe.send.value:
        return { ...r, transactionIntentHash: o.transactionIntentHash };
      default:
        return r;
    }
  }, {});
}, pe = {
  oneTimeAccountsWithoutProofOfOwnership: "oneTimeAccountsWithoutProofOfOwnership",
  oneTimeAccountsWithProofOfOwnership: "oneTimeAccountsWithProofOfOwnership",
  ongoingAccountsWithoutProofOfOwnership: "ongoingAccountsWithoutProofOfOwnership",
  ongoingAccountsWithProofOfOwnership: "ongoingAccountsWithProofOfOwnership",
  usePersona: "usePersona",
  loginWithoutChallenge: "loginWithoutChallenge",
  loginWithChallenge: "loginWithChallenge",
  login: "login",
  oneTimePersonaData: "oneTimePersonaData",
  ongoingPersonaData: "ongoingPersonaData"
}, pt = (t) => ({
  quantity: (t == null ? void 0 : t.quantity) || 1,
  quantifier: (t == null ? void 0 : t.quantifier) || "atLeast"
}), Hn = (t) => re(
  Object.entries(t).reduce(
    (e, [n, r]) => {
      switch (n) {
        case pe.oneTimeAccountsWithoutProofOfOwnership:
          return {
            ...e,
            oneTimeAccounts: {
              requiresProofOfOwnership: !1,
              numberOfAccounts: pt(r)
            }
          };
        case pe.oneTimeAccountsWithProofOfOwnership:
          return {
            ...e,
            oneTimeAccounts: {
              requiresProofOfOwnership: !0,
              numberOfAccounts: pt(r)
            }
          };
        case pe.ongoingAccountsWithProofOfOwnership:
          return {
            ...e,
            ongoingAccounts: {
              requiresProofOfOwnership: !0,
              numberOfAccounts: pt(r)
            }
          };
        case pe.ongoingAccountsWithoutProofOfOwnership:
          return {
            ...e,
            ongoingAccounts: {
              requiresProofOfOwnership: !1,
              numberOfAccounts: pt(r)
            }
          };
        case pe.loginWithoutChallenge:
          return {
            ...e,
            auth: { ...r, discriminator: "login" },
            discriminator: "authorizedRequest"
          };
        case pe.usePersona:
          return {
            ...e,
            auth: { ...r, discriminator: "usePersona" },
            discriminator: "authorizedRequest"
          };
        case pe.loginWithChallenge:
          return {
            ...e,
            auth: r,
            discriminator: "authorizedRequest"
          };
        case "send":
          return {
            discriminator: "transaction",
            send: r
          };
        default:
          return {
            ...e,
            [n]: r
          };
      }
    },
    {
      discriminator: "unauthorizedRequest"
    }
  )
), Yn = (t) => (e, n = crypto.randomUUID()) => re({
  items: e,
  interactionId: n,
  metadata: t
}), Oa = {
  send: "send"
}, Ea = {
  ...pe,
  ...Oa
}, Aa = (t, e) => ({
  request: (n, r = {}) => Hn(n).andThen(Yn(t)).asyncAndThen(zn).andThen(e(r)).andThen(Kn).map((i) => i.items).map(Vn),
  sendTransaction: (n, r = {}) => Hn({ [Ea.send]: n }).andThen(Yn(t)).asyncAndThen(zn).andThen(e(r)).andThen(Kn).map((i) => i.items).map(Vn)
});
var ka = /* @__PURE__ */ ((t) => (t.I8 = "i8", t.I16 = "i16", t.I32 = "i32", t.I64 = "i64", t.I128 = "i128", t.U8 = "u8", t.U16 = "u16", t.U32 = "u32", t.U64 = "u64", t.U128 = "u128", t.Unit = "Unit", t.Bool = "Bool", t.String = "String", t.Enum = "Enum", t.Array = "Array", t.Tuple = "Tuple", t.PackageAddress = "PackageAddress", t.ComponentAddress = "ComponentAddress", t.ResourceAddress = "ResourceAddress", t.SystemAddress = "SystemAddress", t.Bucket = "Bucket", t.Proof = "Proof", t.Expression = "Expression", t.Blob = "Blob", t.NonFungibleAddress = "NonFungibleAddress", t.Hash = "Hash", t.EcdsaSecp256k1PublicKey = "EcdsaSecp256k1PublicKey", t.EcdsaSecp256k1Signature = "EcdsaSecp256k1Signature", t.EddsaEd25519PublicKey = "EddsaEd25519PublicKey", t.EddsaEd25519Signature = "EddsaEd25519Signature", t.Decimal = "Decimal", t.PreciseDecimal = "PreciseDecimal", t.NonFungibleId = "NonFungibleId", t))(ka || {});
class M extends Error {
  constructor(e) {
    super(e);
  }
}
const fu = () => "()", du = (t) => `${t}`, hu = (t) => {
  if (t < -128 || t > 127)
    throw new M("Number range exceeded i8");
  return `${t}i8`;
}, pu = (t) => {
  if (t < -32768 || t > 32767)
    throw new M("Number range exceeded i16");
  return `${t}i16`;
}, mu = (t) => {
  if (t < -2147483648 || t > 2147483647)
    throw new M("Number range exceeded i32");
  return `${t}i32`;
}, vu = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-9223372036854775808") || e > BigInt("9223372036854775807"))
    throw new M("Number range exceeded i64");
  return `${t}i64`;
}, yu = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-170141183460469231731687303715884105728") || e > BigInt("170141183460469231731687303715884105727"))
    throw new M("Number range exceeded i128");
  return `${t}i128`;
}, bu = (t) => {
  if (t < 0 || t > 255)
    throw new M("Number range exceeded u8");
  return `${t}u8`;
}, gu = (t) => {
  if (t < 0 || t > 65535)
    throw new M("Number range exceeded u16");
  return `${t}u16`;
}, wu = (t) => {
  if (t < 0 || t > 4294967295)
    throw new M("Number range exceeded u32");
  return `${t}u32`;
}, _u = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("18446744073709551615"))
    throw new M("Number range exceeded u64");
  return `${t}u64`;
}, xu = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("340282366920938463463374607431768211455"))
    throw new M("Number range exceeded u128");
  return `${t}u128`;
}, Su = (t) => `"${t}"`, Tu = (t, ...e) => e.length > 0 ? `Enum("${t}",${e.join(",")})` : `Enum("${t}")`, Ou = (...t) => `Tuple(${t.join(",")})`, Eu = (t, ...e) => (Pa(t, e), `Array<${t}>(${e.join(",")})`), Ia = (t) => `PackageAddress("${t}")`, Ae = (t) => `ComponentAddress("${t}")`, U = (t) => `ResourceAddress("${t}")`, Au = (t) => `SystemAddress("${t}")`, Ue = (t) => typeof t == "string" ? `Bucket("${t}")` : `Bucket(${t}u32)`, ae = (t) => typeof t == "string" ? `Proof("${t}")` : `Proof(${t}u32)`, ku = (t) => `Expression("${t}")`, Iu = (t) => `Blob("${t}")`, Pu = (t, e) => `NonFungibleAddress("${t}", ${e})`, Cu = (t) => `Hash("${t}")`, Ru = (t) => `EcdsaSecp256k1PublicKey("${t}")`, $u = (t) => `EcdsaSecp256k1Signature("${t}")`, ju = (t) => `EddsaEd25519PublicKey("${t}")`, Nu = (t) => `EddsaEd25519Signature("${t}")`, We = (t) => `Decimal("${t}")`, Lu = (t) => `PreciseDecimal("${t}")`, Zu = (t) => `NonFungibleId(${t})`, Pa = (t, e) => {
  if (t === "String") {
    if (e.some((n) => !n.startsWith('"') && !n.endsWith('"')))
      throw new M(`Array<${t}> expects the same type`);
  } else if (t === "Unit") {
    if (e.some((n) => n !== "()"))
      throw new M(`Array<${t}> expects the same type`);
  } else if (e.some((n) => !n.includes(t)))
    throw new M(`Array<${t}> expects the same type`);
};
class Ca {
  constructor(e) {
    it(this, "instructions"), this.instructions = e;
  }
  toString() {
    return this.instructions.join(`
`);
  }
}
class Du {
  constructor() {
    it(this, "instructions"), it(this, "buckets"), it(this, "proofs"), it(this, "id_allocator"), this.instructions = [], this.buckets = /* @__PURE__ */ new Map(), this.proofs = /* @__PURE__ */ new Map(), this.id_allocator = 512;
  }
  takeFromWorktop(e, n) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP ${U(e)} ${Ue(
        n
      )};`
    ), this.buckets.set(n, this.id_allocator++), this;
  }
  takeFromWorktopByAmount(e, n, r) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_AMOUNT ${We(e)} ${U(
        n
      )} ${Ue(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  takeFromWorktopByIds(e, n, r) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_IDS ${e} ${U(
        n
      )} ${Ue(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  returnToWorktop(e) {
    return this.instructions.push(`RETURN_TO_WORKTOP ${Ue(e)};`), this;
  }
  assertWorktopContains(e) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS ${U(e)};`
    ), this;
  }
  assertWorktopContainsByAmount(e, n) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_AMOUNT ${We(e)} ${U(
        n
      )};`
    ), this;
  }
  assertWorktopContainsByIds(e, n) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_IDS ${e} ${U(
        n
      )};`
    ), this;
  }
  popFromAuthZone(e) {
    return this.instructions.push(`POP_FROM_AUTH_ZONE ${ae(e)};`), this.proofs.set(e, this.id_allocator++), this;
  }
  pushToAuthZone(e) {
    return this.instructions.push(`PUSH_TO_AUTH_ZONE ${ae(e)};`), this;
  }
  clearAuthZone() {
    return this.instructions.push("CLEAR_AUTH_ZONE;"), this;
  }
  createProofFromAuthZone(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE ${U(e)} ${ae(
        n
      )};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  createProofFromAuthZoneByAmount(e, n, r) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_AMOUNT ${We(
        e
      )} ${U(n)} ${ae(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromAuthZoneByIds(e, n, r) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_IDS ${e} ${U(
        n
      )} ${ae(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromBucket(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_BUCKET ${Ue(e)} ${ae(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  cloneProof(e, n) {
    return this.instructions.push(
      `CLONE_PROOF ${ae(e)} ${ae(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  dropProof(e) {
    return this.instructions.push(`DROP_PROOF ${ae(e)};`), this;
  }
  callFunction(e, n, r, i) {
    return this.instructions.push(
      `CALL_FUNCTION ${Ia(
        e
      )} "${n}" "${r}" ${i.join(" ")};`
    ), this;
  }
  callMethod(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${Ae(
        e
      )} "${n}" ${r.join(" ")};`
    ), this;
  }
  callNativeFunction(e, n, r) {
    return this.instructions.push(
      'CALL_NATIVE_FUNCTION "' + e + '" "' + n + '" ' + r.join(" ") + ";"
    ), this;
  }
  callNativeMethod(e, n, r) {
    return this.instructions.push(
      "CALL_NATIVE_METHOD " + e + ' "' + n + '" ' + r.join(" ") + ";"
    ), this;
  }
  publishPackageWithOwner(e, n, r) {
    return this.instructions.push(
      'PUBLISH_PACKAGE_WITH_OWNER Blob("' + e + '") Blob("' + n + '") ' + r + ";"
    ), this;
  }
  createResource(e, n, r, i) {
    return this.instructions.push(
      `CREATE_RESOURCE ${e} ${n} ${r} ${i};`
    ), this;
  }
  burnBucket(e) {
    return this.instructions.push(`BURN_BUCKET ${Ue(e)};`), this;
  }
  mintFungible(e, n) {
    return this.instructions.push(
      `MINT_FUNGIBLE ${U(e)} ${We(n)};`
    ), this;
  }
  withdrawFromAccount(e, n) {
    return this.instructions.push(
      `CALL_METHOD ${Ae(
        e
      )} "withdraw" ${U(n)};`
    ), this;
  }
  withdrawFromAccountByAmount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${Ae(
        e
      )} "withdraw_by_amount" ${We(n)} ${U(
        r
      )};`
    ), this;
  }
  withdrawFromAccountByIds(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${Ae(
        e
      )} "withdraw_by_ids" ${n} ${U(
        r
      )};`
    ), this;
  }
  createProofFromAccount(e, n) {
    return this.instructions.push(
      `CALL_METHOD ${Ae(
        e
      )} "create_proof" ${U(n)};`
    ), this;
  }
  createProofFromAccountByAmount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${Ae(
        e
      )} "create_proof_by_amount" ${We(n)} ${U(
        r
      )};`
    ), this;
  }
  createProofFromAccountByIds(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${Ae(
        e
      )} "create_proof_by_ids" ${n} ${U(
        r
      )};`
    ), this;
  }
  build() {
    return new Ca(this.instructions);
  }
}
var Ra = "Expected a function", $a = 9007199254740991, ja = "[object Arguments]", Na = "[object Function]", La = "[object GeneratorFunction]", Za = typeof ot == "object" && ot && ot.Object === Object && ot, Da = typeof self == "object" && self && self.Object === Object && self, qa = Za || Da || Function("return this")();
function Ua(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function Wa(t, e) {
  for (var n = -1, r = e.length, i = t.length; ++n < r; )
    t[i + n] = e[n];
  return t;
}
var mn = Object.prototype, Ma = mn.hasOwnProperty, fi = mn.toString, Jn = qa.Symbol, Fa = mn.propertyIsEnumerable, Gn = Jn ? Jn.isConcatSpreadable : void 0, Qn = Math.max;
function di(t, e, n, r, i) {
  var o = -1, s = t.length;
  for (n || (n = Ka), i || (i = []); ++o < s; ) {
    var a = t[o];
    e > 0 && n(a) ? e > 1 ? di(a, e - 1, n, r, i) : Wa(i, a) : r || (i[i.length] = a);
  }
  return i;
}
function Ba(t, e) {
  return e = Qn(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, r = -1, i = Qn(n.length - e, 0), o = Array(i); ++r < i; )
      o[r] = n[e + r];
    r = -1;
    for (var s = Array(e + 1); ++r < e; )
      s[r] = n[r];
    return s[e] = o, Ua(t, this, s);
  };
}
function za(t) {
  return Ba(function(e) {
    e = di(e, 1);
    var n = e.length, r = n;
    for (t && e.reverse(); r--; )
      if (typeof e[r] != "function")
        throw new TypeError(Ra);
    return function() {
      for (var i = 0, o = n ? e[i].apply(this, arguments) : arguments[0]; ++i < n; )
        o = e[i].call(this, o);
      return o;
    };
  });
}
function Ka(t) {
  return Ha(t) || Va(t) || !!(Gn && t && t[Gn]);
}
function Va(t) {
  return Ja(t) && Ma.call(t, "callee") && (!Fa.call(t, "callee") || fi.call(t) == ja);
}
var Ha = Array.isArray;
function Ya(t) {
  return t != null && Qa(t.length) && !Ga(t);
}
function Ja(t) {
  return eu(t) && Ya(t);
}
function Ga(t) {
  var e = Xa(t) ? fi.call(t) : "";
  return e == Na || e == La;
}
function Qa(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= $a;
}
function Xa(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function eu(t) {
  return !!t && typeof t == "object";
}
var tu = za(), nu = tu;
function qu(...t) {
  return nu(t)({});
}
const ru = {
  withoutChallenge: () => (t) => ({
    ...t,
    loginWithoutChallenge: {
      discriminator: "login"
    }
  }),
  withChallenge: (t) => (e) => ({
    ...e,
    loginWithChallenge: { discriminator: "login", challenge: t }
  })
}, iu = {
  withoutProofOfOwnership: (t = te.defaultNumberOfAccountsQuantity, e = te.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    oneTimeAccountsWithoutProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  }),
  withProofOfOwnership: (t = te.defaultNumberOfAccountsQuantity, e = te.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    oneTimeAccountsWithProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  })
}, ou = (...t) => (e) => ({
  ...e,
  oneTimePersonaData: { fields: t }
}), su = {
  withoutProofOfOwnership: (t = te.defaultNumberOfAccountsQuantity, e = te.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    ongoingAccountsWithoutProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  }),
  withProofOfOwnership: (t = te.defaultNumberOfAccountsQuantity, e = te.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    ongoingAccountsWithProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  })
}, au = (...t) => (e) => ({
  ...e,
  ongoingPersonaData: { fields: t }
}), uu = (t) => (e) => ({
  ...e,
  usePersona: { discriminator: "usePersona", identityAddress: t }
}), Uu = {
  oneTimeAccounts: iu,
  ongoingAccounts: su,
  oneTimePersonaData: ou,
  ongoingPersonaData: au,
  login: ru,
  usePersona: uu
}, cu = {
  Mainnet: 1,
  Stokenet: 2,
  Adapanet: 10,
  Nebunet: 11,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34
}, lu = ({
  networkId: t = cu.Mainnet,
  dAppDefinitionAddress: e,
  logLevel: n = te.logLevel
}) => {
  J.setLevel(n), J.debug(" wallet sdk instantiated");
  const r = As(), i = () => {
    J.debug(" destroying wallet sdk instance"), r.destroy();
  };
  return {
    ...Aa(
      { networkId: t, dAppDefinitionAddress: e },
      Ls(r.subjects)
    ),
    destroy: i,
    __subjects: r.subjects
  };
}, Wu = ({ dAppDefinitionAddress: t, dAppName: e }, n, r) => {
  const {
    networkId: i = 1,
    providers: o,
    logger: s,
    initialState: a,
    onInit: c = () => {
    },
    onDisconnect: u = () => {
    },
    explorer: l
  } = r || {}, p = (o == null ? void 0 : o.storage) || Ao(), f = (o == null ? void 0 : o.connectButton) || So({ logger: s, dAppName: e, explorer: l }), h = (o == null ? void 0 : o.walletClient) || Eo({
    logger: s,
    walletSdk: lu({
      networkId: i,
      dAppDefinitionAddress: t,
      logLevel: "debug"
    })
  }), g = _o({
    connectButtonClient: f,
    initialState: a,
    key: `rdt:${t}:${i}`,
    logger: s,
    onInitCallback: c,
    onDisconnectCallback: u,
    storageClient: p,
    walletClient: h,
    connectRequest: n,
    useDoneCallback: r == null ? void 0 : r.useDoneCallback
  });
  return {
    requestData: g.requestData,
    sendTransaction: h.sendTransaction,
    state$: g.state$,
    destroy: () => {
      g.destroy();
    }
  };
};
export {
  Eu as Array,
  sa as AuthLoginRequestResponseItemSchema,
  aa as AuthRequestItemSchema,
  Iu as Blob,
  du as Bool,
  Ue as Bucket,
  Ae as ComponentAddress,
  We as Decimal,
  Ru as EcdsaSecp256k1PublicKey,
  $u as EcdsaSecp256k1Signature,
  ju as EddsaEd25519PublicKey,
  Nu as EddsaEd25519Signature,
  Tu as Enum,
  zs as ErrorTypeSchema,
  ku as Expression,
  Cu as Hash,
  yu as I128,
  pu as I16,
  mu as I32,
  vu as I64,
  hu as I8,
  Du as ManifestBuilder,
  cu as Network,
  Pu as NonFungibleAddress,
  Zu as NonFungibleId,
  ui as OneTimeAccountsRequestResponseItemSchema,
  Ia as PackageAddress,
  Lu as PreciseDecimal,
  ae as Proof,
  Wu as RadixDappToolkit,
  qe as RequestTypeSchema,
  U as ResourceAddress,
  M as ScryptoValueError,
  Su as String,
  Au as SystemAddress,
  Ou as Tuple,
  ka as TypeId,
  xu as U128,
  gu as U16,
  wu as U32,
  _u as U64,
  bu as U8,
  fu as Unit,
  ba as WalletAuthorizedRequestResponseItemsSchema,
  Sa as WalletInteractionFailureResponseSchema,
  _a as WalletInteractionResponseItemsSchema,
  Ta as WalletInteractionResponseSchema,
  va as WalletInteractionSchema,
  xa as WalletInteractionSuccessResponseSchema,
  ha as WalletRequestItemsSchema,
  ga as WalletRequestResponseItemsSchema,
  lu as WalletSdk,
  wa as WalletTransactionResponseItemsSchema,
  ya as WalletUnauthorizedRequestResponseItemsSchema,
  wt as createSdkError,
  Le as errorType,
  ru as login,
  iu as oneTimeAccounts,
  ou as oneTimePersonaData,
  su as ongoingAccounts,
  au as ongoingPersonaData,
  qu as requestBuilder,
  Uu as requestItem,
  Rs as sdkError,
  uu as usePersona
};
