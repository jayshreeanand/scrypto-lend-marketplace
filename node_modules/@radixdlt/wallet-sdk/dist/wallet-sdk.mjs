var Kn = Object.defineProperty;
var Yn = (t, e, n) => e in t ? Kn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var be = (t, e, n) => (Yn(t, typeof e != "symbol" ? e + "" : e, n), n);
var ut = function(t, e) {
  return ut = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r)
      Object.prototype.hasOwnProperty.call(r, s) && (n[s] = r[s]);
  }, ut(t, e);
};
function oe(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  ut(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
function Gn(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (g) {
        o(g);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (g) {
        o(g);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function sn(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = u;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(u);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        r = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function ke(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, n = e && t[e], r = 0;
  if (n)
    return n.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && r >= t.length && (t = void 0), { value: t && t[r++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function ye(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function ve(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = e.length, i; r < s; r++)
      (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
function Te(t) {
  return this instanceof Te ? (this.v = t, this) : new Te(t);
}
function Qn(t, e, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(t, e || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(m) {
    r[m] && (s[m] = function(b) {
      return new Promise(function($, p) {
        i.push([m, b, $, p]) > 1 || a(m, b);
      });
    });
  }
  function a(m, b) {
    try {
      c(r[m](b));
    } catch ($) {
      g(i[0][3], $);
    }
  }
  function c(m) {
    m.value instanceof Te ? Promise.resolve(m.value.v).then(u, l) : g(i[0][2], m);
  }
  function u(m) {
    a("next", m);
  }
  function l(m) {
    a("throw", m);
  }
  function g(m, b) {
    m(b), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function Jn(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], n;
  return e ? e.call(t) : (t = typeof ke == "function" ? ke(t) : t[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(i) {
    n[i] = t[i] && function(o) {
      return new Promise(function(a, c) {
        o = t[i](o), s(a, c, o.done, o.value);
      });
    };
  }
  function s(i, o, a, c) {
    Promise.resolve(c).then(function(u) {
      i({ value: u, done: a });
    }, o);
  }
}
function C(t) {
  return typeof t == "function";
}
function Pt(t) {
  var e = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = t(e);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var nt = Pt(function(t) {
  return function(n) {
    t(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, s) {
      return s + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function Fe(t, e) {
  if (t) {
    var n = t.indexOf(e);
    0 <= n && t.splice(n, 1);
  }
}
var $e = function() {
  function t(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var e, n, r, s, i;
    if (!this.closed) {
      this.closed = !0;
      var o = this._parentage;
      if (o)
        if (this._parentage = null, Array.isArray(o))
          try {
            for (var a = ke(o), c = a.next(); !c.done; c = a.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (p) {
            e = { error: p };
          } finally {
            try {
              c && !c.done && (n = a.return) && n.call(a);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          o.remove(this);
      var l = this.initialTeardown;
      if (C(l))
        try {
          l();
        } catch (p) {
          i = p instanceof nt ? p.errors : [p];
        }
      var g = this._finalizers;
      if (g) {
        this._finalizers = null;
        try {
          for (var m = ke(g), b = m.next(); !b.done; b = m.next()) {
            var $ = b.value;
            try {
              Zt($);
            } catch (p) {
              i = i ?? [], p instanceof nt ? i = ve(ve([], ye(i)), ye(p.errors)) : i.push(p);
            }
          }
        } catch (p) {
          r = { error: p };
        } finally {
          try {
            b && !b.done && (s = m.return) && s.call(m);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (i)
        throw new nt(i);
    }
  }, t.prototype.add = function(e) {
    var n;
    if (e && e !== this)
      if (this.closed)
        Zt(e);
      else {
        if (e instanceof t) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(e);
      }
  }, t.prototype._hasParent = function(e) {
    var n = this._parentage;
    return n === e || Array.isArray(n) && n.includes(e);
  }, t.prototype._addParent = function(e) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(e), n) : n ? [n, e] : e;
  }, t.prototype._removeParent = function(e) {
    var n = this._parentage;
    n === e ? this._parentage = null : Array.isArray(n) && Fe(n, e);
  }, t.prototype.remove = function(e) {
    var n = this._finalizers;
    n && Fe(n, e), e instanceof t && e._removeParent(this);
  }, t.EMPTY = function() {
    var e = new t();
    return e.closed = !0, e;
  }(), t;
}(), on = $e.EMPTY;
function an(t) {
  return t instanceof $e || t && "closed" in t && C(t.remove) && C(t.add) && C(t.unsubscribe);
}
function Zt(t) {
  C(t) ? t() : t.unsubscribe();
}
var It = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, ct = {
  setTimeout: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = ct.delegate;
    return s != null && s.setTimeout ? s.setTimeout.apply(s, ve([t, e], ye(n))) : setTimeout.apply(void 0, ve([t, e], ye(n)));
  },
  clearTimeout: function(t) {
    var e = ct.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(t);
  },
  delegate: void 0
};
function un(t) {
  ct.setTimeout(function() {
    throw t;
  });
}
function lt() {
}
var We = null;
function Ve(t) {
  if (It.useDeprecatedSynchronousErrorHandling) {
    var e = !We;
    if (e && (We = { errorThrown: !1, error: null }), t(), e) {
      var n = We, r = n.errorThrown, s = n.error;
      if (We = null, r)
        throw s;
    }
  } else
    t();
}
var Rt = function(t) {
  oe(e, t);
  function e(n) {
    var r = t.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, an(n) && n.add(r)) : r.destination = nr, r;
  }
  return e.create = function(n, r, s) {
    return new Pe(n, r, s);
  }, e.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, e.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(n) {
    this.destination.next(n);
  }, e.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}($e), Xn = Function.prototype.bind;
function rt(t, e) {
  return Xn.call(t, e);
}
var er = function() {
  function t(e) {
    this.partialObserver = e;
  }
  return t.prototype.next = function(e) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(e);
      } catch (r) {
        qe(r);
      }
  }, t.prototype.error = function(e) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(e);
      } catch (r) {
        qe(r);
      }
    else
      qe(e);
  }, t.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (n) {
        qe(n);
      }
  }, t;
}(), Pe = function(t) {
  oe(e, t);
  function e(n, r, s) {
    var i = t.call(this) || this, o;
    if (C(n) || !n)
      o = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: s ?? void 0
      };
    else {
      var a;
      i && It.useDeprecatedNextContext ? (a = Object.create(n), a.unsubscribe = function() {
        return i.unsubscribe();
      }, o = {
        next: n.next && rt(n.next, a),
        error: n.error && rt(n.error, a),
        complete: n.complete && rt(n.complete, a)
      }) : o = n;
    }
    return i.destination = new er(o), i;
  }
  return e;
}(Rt);
function qe(t) {
  un(t);
}
function tr(t) {
  throw t;
}
var nr = {
  closed: !0,
  next: lt,
  error: tr,
  complete: lt
}, Ct = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Xe(t) {
  return t;
}
function rr(t) {
  return t.length === 0 ? Xe : t.length === 1 ? t[0] : function(n) {
    return t.reduce(function(r, s) {
      return s(r);
    }, n);
  };
}
var Z = function() {
  function t(e) {
    e && (this._subscribe = e);
  }
  return t.prototype.lift = function(e) {
    var n = new t();
    return n.source = this, n.operator = e, n;
  }, t.prototype.subscribe = function(e, n, r) {
    var s = this, i = ir(e) ? e : new Pe(e, n, r);
    return Ve(function() {
      var o = s, a = o.operator, c = o.source;
      i.add(a ? a.call(i, c) : c ? s._subscribe(i) : s._trySubscribe(i));
    }), i;
  }, t.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (n) {
      e.error(n);
    }
  }, t.prototype.forEach = function(e, n) {
    var r = this;
    return n = Dt(n), new n(function(s, i) {
      var o = new Pe({
        next: function(a) {
          try {
            e(a);
          } catch (c) {
            i(c), o.unsubscribe();
          }
        },
        error: i,
        complete: s
      });
      r.subscribe(o);
    });
  }, t.prototype._subscribe = function(e) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e);
  }, t.prototype[Ct] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var e = [], n = 0; n < arguments.length; n++)
      e[n] = arguments[n];
    return rr(e)(this);
  }, t.prototype.toPromise = function(e) {
    var n = this;
    return e = Dt(e), new e(function(r, s) {
      var i;
      n.subscribe(function(o) {
        return i = o;
      }, function(o) {
        return s(o);
      }, function() {
        return r(i);
      });
    });
  }, t.create = function(e) {
    return new t(e);
  }, t;
}();
function Dt(t) {
  var e;
  return (e = t ?? It.Promise) !== null && e !== void 0 ? e : Promise;
}
function sr(t) {
  return t && C(t.next) && C(t.error) && C(t.complete);
}
function ir(t) {
  return t && t instanceof Rt || sr(t) && an(t);
}
function or(t) {
  return C(t == null ? void 0 : t.lift);
}
function q(t) {
  return function(e) {
    if (or(e))
      return e.lift(function(n) {
        try {
          return t(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function z(t, e, n, r, s) {
  return new ar(t, e, n, r, s);
}
var ar = function(t) {
  oe(e, t);
  function e(n, r, s, i, o, a) {
    var c = t.call(this, n) || this;
    return c.onFinalize = o, c.shouldUnsubscribe = a, c._next = r ? function(u) {
      try {
        r(u);
      } catch (l) {
        n.error(l);
      }
    } : t.prototype._next, c._error = i ? function(u) {
      try {
        i(u);
      } catch (l) {
        n.error(l);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._error, c._complete = s ? function() {
      try {
        s();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : t.prototype._complete, c;
  }
  return e.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      t.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, e;
}(Rt), ur = Pt(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), te = function(t) {
  oe(e, t);
  function e() {
    var n = t.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return e.prototype.lift = function(n) {
    var r = new Wt(this, this);
    return r.operator = n, r;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new ur();
  }, e.prototype.next = function(n) {
    var r = this;
    Ve(function() {
      var s, i;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var o = ke(r.currentObservers), a = o.next(); !a.done; a = o.next()) {
            var c = a.value;
            c.next(n);
          }
        } catch (u) {
          s = { error: u };
        } finally {
          try {
            a && !a.done && (i = o.return) && i.call(o);
          } finally {
            if (s)
              throw s.error;
          }
        }
      }
    });
  }, e.prototype.error = function(n) {
    var r = this;
    Ve(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var s = r.observers; s.length; )
          s.shift().error(n);
      }
    });
  }, e.prototype.complete = function() {
    var n = this;
    Ve(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, n);
  }, e.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, e.prototype._innerSubscribe = function(n) {
    var r = this, s = this, i = s.hasError, o = s.isStopped, a = s.observers;
    return i || o ? on : (this.currentObservers = null, a.push(n), new $e(function() {
      r.currentObservers = null, Fe(a, n);
    }));
  }, e.prototype._checkFinalizedStatuses = function(n) {
    var r = this, s = r.hasError, i = r.thrownError, o = r.isStopped;
    s ? n.error(i) : o && n.complete();
  }, e.prototype.asObservable = function() {
    var n = new Z();
    return n.source = this, n;
  }, e.create = function(n, r) {
    return new Wt(n, r);
  }, e;
}(Z), Wt = function(t) {
  oe(e, t);
  function e(n, r) {
    var s = t.call(this) || this;
    return s.destination = n, s.source = r, s;
  }
  return e.prototype.next = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || s === void 0 || s.call(r, n);
  }, e.prototype.error = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || s === void 0 || s.call(r, n);
  }, e.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, e.prototype._subscribe = function(n) {
    var r, s;
    return (s = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && s !== void 0 ? s : on;
  }, e;
}(te), cn = {
  now: function() {
    return (cn.delegate || Date).now();
  },
  delegate: void 0
}, cr = function(t) {
  oe(e, t);
  function e(n, r) {
    return t.call(this) || this;
  }
  return e.prototype.schedule = function(n, r) {
    return this;
  }, e;
}($e), ze = {
  setInterval: function(t, e) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = ze.delegate;
    return s != null && s.setInterval ? s.setInterval.apply(s, ve([t, e], ye(n))) : setInterval.apply(void 0, ve([t, e], ye(n)));
  },
  clearInterval: function(t) {
    var e = ze.delegate;
    return ((e == null ? void 0 : e.clearInterval) || clearInterval)(t);
  },
  delegate: void 0
}, lr = function(t) {
  oe(e, t);
  function e(n, r) {
    var s = t.call(this, n, r) || this;
    return s.scheduler = n, s.work = r, s.pending = !1, s;
  }
  return e.prototype.schedule = function(n, r) {
    var s;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var i = this.id, o = this.scheduler;
    return i != null && (this.id = this.recycleAsyncId(o, i, r)), this.pending = !0, this.delay = r, this.id = (s = this.id) !== null && s !== void 0 ? s : this.requestAsyncId(o, this.id, r), this;
  }, e.prototype.requestAsyncId = function(n, r, s) {
    return s === void 0 && (s = 0), ze.setInterval(n.flush.bind(n, this), s);
  }, e.prototype.recycleAsyncId = function(n, r, s) {
    if (s === void 0 && (s = 0), s != null && this.delay === s && this.pending === !1)
      return r;
    r != null && ze.clearInterval(r);
  }, e.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var s = this._execute(n, r);
    if (s)
      return s;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(n, r) {
    var s = !1, i;
    try {
      this.work(n);
    } catch (o) {
      s = !0, i = o || new Error("Scheduled action threw falsy error");
    }
    if (s)
      return this.unsubscribe(), i;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, s = n.scheduler, i = s.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, Fe(i, this), r != null && (this.id = this.recycleAsyncId(s, r, null)), this.delay = null, t.prototype.unsubscribe.call(this);
    }
  }, e;
}(cr), qt = function() {
  function t(e, n) {
    n === void 0 && (n = t.now), this.schedulerActionCtor = e, this.now = n;
  }
  return t.prototype.schedule = function(e, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, e).schedule(r, n);
  }, t.now = cn.now, t;
}(), dr = function(t) {
  oe(e, t);
  function e(n, r) {
    r === void 0 && (r = qt.now);
    var s = t.call(this, n, r) || this;
    return s.actions = [], s._active = !1, s;
  }
  return e.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var s;
    this._active = !0;
    do
      if (s = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = !1, s) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw s;
    }
  }, e;
}(qt), fr = new dr(lr), hr = fr, ln = new Z(function(t) {
  return t.complete();
});
function dn(t) {
  return t && C(t.schedule);
}
function fn(t) {
  return t[t.length - 1];
}
function hn(t) {
  return dn(fn(t)) ? t.pop() : void 0;
}
function pr(t, e) {
  return typeof fn(t) == "number" ? t.pop() : e;
}
var pn = function(t) {
  return t && typeof t.length == "number" && typeof t != "function";
};
function mn(t) {
  return C(t == null ? void 0 : t.then);
}
function yn(t) {
  return C(t[Ct]);
}
function vn(t) {
  return Symbol.asyncIterator && C(t == null ? void 0 : t[Symbol.asyncIterator]);
}
function gn(t) {
  return new TypeError("You provided " + (t !== null && typeof t == "object" ? "an invalid object" : "'" + t + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function mr() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var _n = mr();
function bn(t) {
  return C(t == null ? void 0 : t[_n]);
}
function wn(t) {
  return Qn(this, arguments, function() {
    var n, r, s, i;
    return sn(this, function(o) {
      switch (o.label) {
        case 0:
          n = t.getReader(), o.label = 1;
        case 1:
          o.trys.push([1, , 9, 10]), o.label = 2;
        case 2:
          return [4, Te(n.read())];
        case 3:
          return r = o.sent(), s = r.value, i = r.done, i ? [4, Te(void 0)] : [3, 5];
        case 4:
          return [2, o.sent()];
        case 5:
          return [4, Te(s)];
        case 6:
          return [4, o.sent()];
        case 7:
          return o.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function xn(t) {
  return C(t == null ? void 0 : t.getReader);
}
function ae(t) {
  if (t instanceof Z)
    return t;
  if (t != null) {
    if (yn(t))
      return yr(t);
    if (pn(t))
      return vr(t);
    if (mn(t))
      return gr(t);
    if (vn(t))
      return Sn(t);
    if (bn(t))
      return _r(t);
    if (xn(t))
      return br(t);
  }
  throw gn(t);
}
function yr(t) {
  return new Z(function(e) {
    var n = t[Ct]();
    if (C(n.subscribe))
      return n.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function vr(t) {
  return new Z(function(e) {
    for (var n = 0; n < t.length && !e.closed; n++)
      e.next(t[n]);
    e.complete();
  });
}
function gr(t) {
  return new Z(function(e) {
    t.then(function(n) {
      e.closed || (e.next(n), e.complete());
    }, function(n) {
      return e.error(n);
    }).then(null, un);
  });
}
function _r(t) {
  return new Z(function(e) {
    var n, r;
    try {
      for (var s = ke(t), i = s.next(); !i.done; i = s.next()) {
        var o = i.value;
        if (e.next(o), e.closed)
          return;
      }
    } catch (a) {
      n = { error: a };
    } finally {
      try {
        i && !i.done && (r = s.return) && r.call(s);
      } finally {
        if (n)
          throw n.error;
      }
    }
    e.complete();
  });
}
function Sn(t) {
  return new Z(function(e) {
    wr(t, e).catch(function(n) {
      return e.error(n);
    });
  });
}
function br(t) {
  return Sn(wn(t));
}
function wr(t, e) {
  var n, r, s, i;
  return Gn(this, void 0, void 0, function() {
    var o, a;
    return sn(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = Jn(t), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (o = r.value, e.next(o), e.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return a = c.sent(), s = { error: a }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (i = n.return) ? [4, i.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (s)
            throw s.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function ne(t, e, n, r, s) {
  r === void 0 && (r = 0), s === void 0 && (s = !1);
  var i = e.schedule(function() {
    n(), s ? t.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (t.add(i), !s)
    return i;
}
function On(t, e) {
  return e === void 0 && (e = 0), q(function(n, r) {
    n.subscribe(z(r, function(s) {
      return ne(r, t, function() {
        return r.next(s);
      }, e);
    }, function() {
      return ne(r, t, function() {
        return r.complete();
      }, e);
    }, function(s) {
      return ne(r, t, function() {
        return r.error(s);
      }, e);
    }));
  });
}
function Tn(t, e) {
  return e === void 0 && (e = 0), q(function(n, r) {
    r.add(t.schedule(function() {
      return n.subscribe(r);
    }, e));
  });
}
function xr(t, e) {
  return ae(t).pipe(Tn(e), On(e));
}
function Sr(t, e) {
  return ae(t).pipe(Tn(e), On(e));
}
function Or(t, e) {
  return new Z(function(n) {
    var r = 0;
    return e.schedule(function() {
      r === t.length ? n.complete() : (n.next(t[r++]), n.closed || this.schedule());
    });
  });
}
function Tr(t, e) {
  return new Z(function(n) {
    var r;
    return ne(n, e, function() {
      r = t[_n](), ne(n, e, function() {
        var s, i, o;
        try {
          s = r.next(), i = s.value, o = s.done;
        } catch (a) {
          n.error(a);
          return;
        }
        o ? n.complete() : n.next(i);
      }, 0, !0);
    }), function() {
      return C(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function En(t, e) {
  if (!t)
    throw new Error("Iterable cannot be null");
  return new Z(function(n) {
    ne(n, e, function() {
      var r = t[Symbol.asyncIterator]();
      ne(n, e, function() {
        r.next().then(function(s) {
          s.done ? n.complete() : n.next(s.value);
        });
      }, 0, !0);
    });
  });
}
function Er(t, e) {
  return En(wn(t), e);
}
function Ar(t, e) {
  if (t != null) {
    if (yn(t))
      return xr(t, e);
    if (pn(t))
      return Or(t, e);
    if (mn(t))
      return Sr(t, e);
    if (vn(t))
      return En(t, e);
    if (bn(t))
      return Tr(t, e);
    if (xn(t))
      return Er(t, e);
  }
  throw gn(t);
}
function An(t, e) {
  return e ? Ar(t, e) : ae(t);
}
function kr() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = hn(t);
  return An(t, n);
}
var $t = Pt(function(t) {
  return function() {
    t(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function Pr(t, e) {
  var n = typeof e == "object";
  return new Promise(function(r, s) {
    var i = new Pe({
      next: function(o) {
        r(o), i.unsubscribe();
      },
      error: s,
      complete: function() {
        n ? r(e.defaultValue) : s(new $t());
      }
    });
    t.subscribe(i);
  });
}
function Ir(t) {
  return t instanceof Date && !isNaN(t);
}
function je(t, e) {
  return q(function(n, r) {
    var s = 0;
    n.subscribe(z(r, function(i) {
      r.next(t.call(e, i, s++));
    }));
  });
}
function Rr(t, e, n, r, s, i, o, a) {
  var c = [], u = 0, l = 0, g = !1, m = function() {
    g && !c.length && !u && e.complete();
  }, b = function(p) {
    return u < r ? $(p) : c.push(p);
  }, $ = function(p) {
    i && e.next(p), u++;
    var k = !1;
    ae(n(p, l++)).subscribe(z(e, function(P) {
      s == null || s(P), i ? b(P) : e.next(P);
    }, function() {
      k = !0;
    }, void 0, function() {
      if (k)
        try {
          u--;
          for (var P = function() {
            var x = c.shift();
            o ? ne(e, o, function() {
              return $(x);
            }) : $(x);
          }; c.length && u < r; )
            P();
          m();
        } catch (x) {
          e.error(x);
        }
    }));
  };
  return t.subscribe(z(e, b, function() {
    g = !0, m();
  })), function() {
    a == null || a();
  };
}
function kn(t, e, n) {
  return n === void 0 && (n = 1 / 0), C(e) ? kn(function(r, s) {
    return je(function(i, o) {
      return e(r, i, s, o);
    })(ae(t(r, s)));
  }, n) : (typeof e == "number" && (n = e), q(function(r, s) {
    return Rr(r, s, t, n);
  }));
}
function Cr(t) {
  return t === void 0 && (t = 1 / 0), kn(Xe, t);
}
function $r(t, e, n) {
  t === void 0 && (t = 0), n === void 0 && (n = hr);
  var r = -1;
  return e != null && (dn(e) ? n = e : r = e), new Z(function(s) {
    var i = Ir(t) ? +t - n.now() : t;
    i < 0 && (i = 0);
    var o = 0;
    return n.schedule(function() {
      s.closed || (s.next(o++), 0 <= r ? this.schedule(void 0, r) : s.complete());
    }, i);
  });
}
function st() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  var n = hn(t), r = pr(t, 1 / 0), s = t;
  return s.length ? s.length === 1 ? ae(s[0]) : Cr(r)(An(s, n)) : ln;
}
function Me(t, e) {
  return q(function(n, r) {
    var s = 0;
    n.subscribe(z(r, function(i) {
      return t.call(e, i, s++) && r.next(i);
    }));
  });
}
function Nr(t) {
  return q(function(e, n) {
    var r = !1;
    e.subscribe(z(n, function(s) {
      r = !0, n.next(s);
    }, function() {
      r || n.next(t), n.complete();
    }));
  });
}
function jr(t) {
  return t <= 0 ? function() {
    return ln;
  } : q(function(e, n) {
    var r = 0;
    e.subscribe(z(n, function(s) {
      ++r <= t && (n.next(s), t <= r && n.complete());
    }));
  });
}
function Mr(t) {
  return t === void 0 && (t = Lr), q(function(e, n) {
    var r = !1;
    e.subscribe(z(n, function(s) {
      r = !0, n.next(s);
    }, function() {
      return r ? n.complete() : n.error(t());
    }));
  });
}
function Lr() {
  return new $t();
}
function Bt(t, e) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(t ? Me(function(s, i) {
      return t(s, i, r);
    }) : Xe, jr(1), n ? Nr(e) : Mr(function() {
      return new $t();
    }));
  };
}
function Pn(t) {
  t === void 0 && (t = {});
  var e = t.connector, n = e === void 0 ? function() {
    return new te();
  } : e, r = t.resetOnError, s = r === void 0 ? !0 : r, i = t.resetOnComplete, o = i === void 0 ? !0 : i, a = t.resetOnRefCountZero, c = a === void 0 ? !0 : a;
  return function(u) {
    var l, g, m, b = 0, $ = !1, p = !1, k = function() {
      g == null || g.unsubscribe(), g = void 0;
    }, P = function() {
      k(), l = m = void 0, $ = p = !1;
    }, x = function() {
      var X = l;
      P(), X == null || X.unsubscribe();
    };
    return q(function(X, j) {
      b++, !p && !$ && k();
      var _e = m = m ?? n();
      j.add(function() {
        b--, b === 0 && !p && !$ && (g = it(x, c));
      }), _e.subscribe(j), !l && b > 0 && (l = new Pe({
        next: function(ue) {
          return _e.next(ue);
        },
        error: function(ue) {
          p = !0, k(), g = it(P, s, ue), _e.error(ue);
        },
        complete: function() {
          $ = !0, k(), g = it(P, o), _e.complete();
        }
      }), ae(X).subscribe(l));
    })(u);
  };
}
function it(t, e) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (e === !0) {
    t();
    return;
  }
  if (e !== !1) {
    var s = new Pe({
      next: function() {
        s.unsubscribe(), t();
      }
    });
    return e.apply(void 0, ve([], ye(n))).subscribe(s);
  }
}
function Ur(t) {
  return q(function(e, n) {
    ae(t).subscribe(z(n, function() {
      return n.complete();
    }, lt)), !n.closed && e.subscribe(n);
  });
}
function Ee(t, e, n) {
  var r = C(t) || e || n ? { next: t, error: e, complete: n } : t;
  return r ? q(function(s, i) {
    var o;
    (o = r.subscribe) === null || o === void 0 || o.call(r);
    var a = !0;
    s.subscribe(z(i, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), i.next(c);
    }, function() {
      var c;
      a = !1, (c = r.complete) === null || c === void 0 || c.call(r), i.complete();
    }, function(c) {
      var u;
      a = !1, (u = r.error) === null || u === void 0 || u.call(r, c), i.error(c);
    }, function() {
      var c, u;
      a && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : Xe;
}
const Zr = () => ({
  outgoingMessageSubject: new te(),
  incomingMessageSubject: new te(),
  responseSubject: new te(),
  messageLifeCycleEventSubject: new te(),
  dispatchEventSubject: new te()
}), dt = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
}, Dr = (t) => t.outgoingMessageSubject.pipe(
  je((e) => ({
    event: dt.outgoingMessage,
    payload: e
  })),
  Ee((e) => {
    t.dispatchEventSubject.next(e);
  }),
  Pn()
);
var Ne = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, In = { exports: {} };
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : e.log = n();
  })(Ne, function() {
    var e = function() {
    }, n = "undefined", r = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), s = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ];
    function i(p, k) {
      var P = p[k];
      if (typeof P.bind == "function")
        return P.bind(p);
      try {
        return Function.prototype.bind.call(P, p);
      } catch {
        return function() {
          return Function.prototype.apply.apply(P, [p, arguments]);
        };
      }
    }
    function o() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function a(p) {
      return p === "debug" && (p = "log"), typeof console === n ? !1 : p === "trace" && r ? o : console[p] !== void 0 ? i(console, p) : console.log !== void 0 ? i(console, "log") : e;
    }
    function c(p, k) {
      for (var P = 0; P < s.length; P++) {
        var x = s[P];
        this[x] = P < p ? e : this.methodFactory(x, p, k);
      }
      this.log = this.debug;
    }
    function u(p, k, P) {
      return function() {
        typeof console !== n && (c.call(this, k, P), this[p].apply(this, arguments));
      };
    }
    function l(p, k, P) {
      return a(p) || u.apply(this, arguments);
    }
    function g(p, k, P) {
      var x = this, X;
      k = k ?? "WARN";
      var j = "loglevel";
      typeof p == "string" ? j += ":" + p : typeof p == "symbol" && (j = void 0);
      function _e(E) {
        var ce = (s[E] || "silent").toUpperCase();
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage[j] = ce;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=" + ce + ";";
          } catch {
          }
        }
      }
      function ue() {
        var E;
        if (!(typeof window === n || !j)) {
          try {
            E = window.localStorage[j];
          } catch {
          }
          if (typeof E === n)
            try {
              var ce = window.document.cookie, De = ce.indexOf(
                encodeURIComponent(j) + "="
              );
              De !== -1 && (E = /^([^;]+)/.exec(ce.slice(De))[1]);
            } catch {
            }
          return x.levels[E] === void 0 && (E = void 0), E;
        }
      }
      function zn() {
        if (!(typeof window === n || !j)) {
          try {
            window.localStorage.removeItem(j);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(j) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      x.name = p, x.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, x.methodFactory = P || l, x.getLevel = function() {
        return X;
      }, x.setLevel = function(E, ce) {
        if (typeof E == "string" && x.levels[E.toUpperCase()] !== void 0 && (E = x.levels[E.toUpperCase()]), typeof E == "number" && E >= 0 && E <= x.levels.SILENT) {
          if (X = E, ce !== !1 && _e(E), c.call(x, E, p), typeof console === n && E < x.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + E;
      }, x.setDefaultLevel = function(E) {
        k = E, ue() || x.setLevel(E, !1);
      }, x.resetLevel = function() {
        x.setLevel(k, !1), zn();
      }, x.enableAll = function(E) {
        x.setLevel(x.levels.TRACE, E);
      }, x.disableAll = function(E) {
        x.setLevel(x.levels.SILENT, E);
      };
      var tt = ue();
      tt == null && (tt = k), x.setLevel(tt, !1);
    }
    var m = new g(), b = {};
    m.getLogger = function(k) {
      if (typeof k != "symbol" && typeof k != "string" || k === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var P = b[k];
      return P || (P = b[k] = new g(
        k,
        m.getLevel(),
        m.methodFactory
      )), P;
    };
    var $ = typeof window !== n ? window.log : void 0;
    return m.noConflict = function() {
      return typeof window !== n && window.log === m && (window.log = $), m;
    }, m.getLoggers = function() {
      return b;
    }, m.default = m, m;
  });
})(In);
const W = In.exports, Wr = (t) => t.incomingMessageSubject.pipe(
  Ee((e) => {
    "eventType" in e ? (W.debug(
      `ðŸ”µðŸ’¬â¬‡ï¸ message lifecycle event
${JSON.stringify(e, null, 2)}`
    ), t.messageLifeCycleEventSubject.next(e)) : (W.debug(`ðŸ”µâ¬‡ï¸ wallet response
${JSON.stringify(e, null, 2)}`), t.responseSubject.next(e));
  })
), qr = (t) => t.dispatchEventSubject.pipe(
  Ee(({ event: e, payload: n }) => {
    W.debug(`ðŸ”µâ¬†ï¸ wallet request
${JSON.stringify(n, null, 2)}`), window.dispatchEvent(
      new CustomEvent(e, {
        detail: n
      })
    );
  })
), Br = (t) => {
  const e = new $e();
  return e.add(qr(t).subscribe()), e.add(Dr(t).subscribe()), e.add(Wr(t).subscribe()), e;
}, Vr = (t) => {
  const e = (r) => {
    const s = r.detail;
    t.incomingMessageSubject.next(s);
  };
  return addEventListener(dt.incomingMessage, e), { destroy: () => {
    removeEventListener(dt.incomingMessage, e);
  } };
}, Fr = (t = Zr()) => {
  const e = Br(t), n = Vr(t);
  return { destroy: () => {
    n.destroy(), e.unsubscribe();
  }, subjects: t };
};
function ot(t, e, n, r) {
  function s(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function a(l) {
      try {
        u(r.next(l));
      } catch (g) {
        o(g);
      }
    }
    function c(l) {
      try {
        u(r.throw(l));
      } catch (g) {
        o(g);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c);
    }
    u((r = r.apply(t, e || [])).next());
  });
}
function at(t, e) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < i[1]) {
              n.label = i[1], i = u;
              break;
            }
            if (i && n.label < i[2]) {
              n.label = i[2], n.ops.push(u);
              break;
            }
            i[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = e.call(t, n);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        r = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function He(t, e) {
  var n = typeof Symbol == "function" && t[Symbol.iterator];
  if (!n)
    return t;
  var r = n.call(t), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = r.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function pe(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = e.length, i; r < s; r++)
      (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var zr = {
  withStackTrace: !1
}, Rn = function(t, e, n) {
  n === void 0 && (n = zr);
  var r = e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, s = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: t,
    stack: s
  };
}, J = function() {
  function t(e) {
    this._promise = e;
  }
  return t.fromSafePromise = function(e) {
    var n = e.then(function(r) {
      return new de(r);
    });
    return new t(n);
  }, t.fromPromise = function(e, n) {
    var r = e.then(function(s) {
      return new de(s);
    }).catch(function(s) {
      return new fe(n(s));
    });
    return new t(r);
  }, t.combine = function(e) {
    return Kr(e);
  }, t.combineWithAllErrors = function(e) {
    return Yr(e);
  }, t.prototype.map = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return ot(n, void 0, void 0, function() {
        var s;
        return at(this, function(i) {
          switch (i.label) {
            case 0:
              return r.isErr() ? [2, new fe(r.error)] : (s = de.bind, [4, e(r.value)]);
            case 1:
              return [2, new (s.apply(de, [void 0, i.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.mapErr = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return ot(n, void 0, void 0, function() {
        var s;
        return at(this, function(i) {
          switch (i.label) {
            case 0:
              return r.isOk() ? [2, new de(r.value)] : (s = fe.bind, [4, e(r.error)]);
            case 1:
              return [2, new (s.apply(fe, [void 0, i.sent()]))()];
          }
        });
      });
    }));
  }, t.prototype.andThen = function(e) {
    return new t(this._promise.then(function(n) {
      if (n.isErr())
        return new fe(n.error);
      var r = e(n.value);
      return r instanceof t ? r._promise : r;
    }));
  }, t.prototype.orElse = function(e) {
    var n = this;
    return new t(this._promise.then(function(r) {
      return ot(n, void 0, void 0, function() {
        return at(this, function(s) {
          return r.isErr() ? [2, e(r.error)] : [2, new de(r.value)];
        });
      });
    }));
  }, t.prototype.match = function(e, n) {
    return this._promise.then(function(r) {
      return r.match(e, n);
    });
  }, t.prototype.unwrapOr = function(e) {
    return this._promise.then(function(n) {
      return n.unwrapOr(e);
    });
  }, t.prototype.then = function(e, n) {
    return this._promise.then(e, n);
  }, t;
}(), Vt = function(t) {
  return new J(Promise.resolve(new fe(t)));
};
J.fromPromise;
J.fromSafePromise;
var Hr = function(t) {
  return function(e) {
    return pe(pe([], He(e), !1), [t], !1);
  };
}, Cn = function(t) {
  return t.reduce(function(e, n) {
    return e.isOk() ? n.isErr() ? F(n.error) : e.map(Hr(n.value)) : e;
  }, V([]));
}, Kr = function(t) {
  return J.fromSafePromise(Promise.all(t)).andThen(Cn);
}, $n = function(t) {
  return t.reduce(function(e, n) {
    return n.isErr() ? e.isErr() ? F(pe(pe([], He(e.error), !1), [n.error], !1)) : F([n.error]) : e.isErr() ? e : V(pe(pe([], He(e.value), !1), [n.value], !1));
  }, V([]));
}, Yr = function(t) {
  return J.fromSafePromise(Promise.all(t)).andThen($n);
}, ft;
(function(t) {
  function e(s, i) {
    return function() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      try {
        var c = s.apply(void 0, pe([], He(o), !1));
        return V(c);
      } catch (u) {
        return F(i ? i(u) : u);
      }
    };
  }
  t.fromThrowable = e;
  function n(s) {
    return Cn(s);
  }
  t.combine = n;
  function r(s) {
    return $n(s);
  }
  t.combineWithAllErrors = r;
})(ft || (ft = {}));
var V = function(t) {
  return new de(t);
}, F = function(t) {
  return new fe(t);
}, de = function() {
  function t(e) {
    this.value = e;
  }
  return t.prototype.isOk = function() {
    return !0;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return V(e(this.value));
  }, t.prototype.mapErr = function(e) {
    return V(this.value);
  }, t.prototype.andThen = function(e) {
    return e(this.value);
  }, t.prototype.orElse = function(e) {
    return V(this.value);
  }, t.prototype.asyncAndThen = function(e) {
    return e(this.value);
  }, t.prototype.asyncMap = function(e) {
    return J.fromSafePromise(e(this.value));
  }, t.prototype.unwrapOr = function(e) {
    return this.value;
  }, t.prototype.match = function(e, n) {
    return e(this.value);
  }, t.prototype._unsafeUnwrap = function(e) {
    return this.value;
  }, t.prototype._unsafeUnwrapErr = function(e) {
    throw Rn("Called `_unsafeUnwrapErr` on an Ok", this, e);
  }, t;
}(), fe = function() {
  function t(e) {
    this.error = e;
  }
  return t.prototype.isOk = function() {
    return !1;
  }, t.prototype.isErr = function() {
    return !this.isOk();
  }, t.prototype.map = function(e) {
    return F(this.error);
  }, t.prototype.mapErr = function(e) {
    return F(e(this.error));
  }, t.prototype.andThen = function(e) {
    return F(this.error);
  }, t.prototype.orElse = function(e) {
    return e(this.error);
  }, t.prototype.asyncAndThen = function(e) {
    return Vt(this.error);
  }, t.prototype.asyncMap = function(e) {
    return Vt(this.error);
  }, t.prototype.unwrapOr = function(e) {
    return e;
  }, t.prototype.match = function(e, n) {
    return n(this.error);
  }, t.prototype._unsafeUnwrap = function(e) {
    throw Rn("Called `_unsafeUnwrap` on an Err", this, e);
  }, t.prototype._unsafeUnwrapErr = function(e) {
    return this.error;
  }, t;
}();
ft.fromThrowable;
const B = {
  extensionDetectionTime: 100,
  defaultNumberOfAccountsQuantity: 1,
  defaultNumberOfAccountsQuantifier: "atLeast",
  logLevel: "info"
}, Gr = (t) => t, me = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee"
}, Qr = (/* @__PURE__ */ new Map()).set(me.missingExtension, "extension could not be found").set(me.rejectedByUser, "user rejected request").set(me.canceledByUser, "user has canceled the request"), Ke = (t, e, n) => ({
  error: t,
  interactionId: e,
  message: n || Qr.get(t) || ""
}), Jr = (t) => J.fromPromise(Pr(t), Gr).andThen(
  (e) => e
), Xr = (t, e) => t.messageLifeCycleEventSubject.pipe(
  Me((n) => n.interactionId === e)
), es = (t) => (e) => (n) => {
  const r = new te();
  e.requestControl && e.requestControl({
    cancelRequest: () => (W.debug(
      `ðŸ”µâ¬†ï¸âŒ wallet request canceled
${JSON.stringify(
        n,
        null,
        2
      )}`
    ), r.next())
  });
  const s = r.asObservable().pipe(
    je(
      () => F(Ke(me.canceledByUser, n.interactionId))
    )
  ), i = t.responseSubject.pipe(
    Me((b) => b.interactionId === n.interactionId),
    je(
      (b) => "items" in b ? V(b) : F(b)
    )
  ), o = st(
    i,
    s
  ).pipe(Bt()), a = Xr(t, n.interactionId).pipe(
    Ee((b) => {
      e.eventCallback && e.eventCallback(b.eventType);
    }),
    Ur(i),
    Pn()
  ), c = a.subscribe(), u = $r(B.extensionDetectionTime).pipe(
    je(
      () => F(Ke(me.missingExtension, n.interactionId))
    )
  ), l = st(
    u,
    a
  ).pipe(
    Bt(),
    Me((b) => !("eventType" in b))
  ), g = kr(!0).pipe(
    Ee(() => {
      t.outgoingMessageSubject.next(n);
    }),
    Me(() => !1)
  ), m = st(
    o,
    l,
    g
  ).pipe(
    Ee(() => {
      c.unsubscribe();
    })
  );
  return Jr(m);
};
var A;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function n(s) {
    throw new Error();
  }
  t.assertNever = n, t.arrayToEnum = (s) => {
    const i = {};
    for (const o of s)
      i[o] = o;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((a) => typeof s[s[a]] != "number"), o = {};
    for (const a of i)
      o[a] = s[a];
    return t.objectValues(o);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
    return i;
  }, t.find = (s, i) => {
    for (const o of s)
      if (i(o))
        return o;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, i = " | ") {
    return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(i);
  }
  t.joinValues = r, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(A || (A = {}));
const f = A.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), he = (t) => {
  switch (typeof t) {
    case "undefined":
      return f.undefined;
    case "string":
      return f.string;
    case "number":
      return isNaN(t) ? f.nan : f.number;
    case "boolean":
      return f.boolean;
    case "function":
      return f.function;
    case "bigint":
      return f.bigint;
    case "object":
      return Array.isArray(t) ? f.array : t === null ? f.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? f.promise : typeof Map < "u" && t instanceof Map ? f.map : typeof Set < "u" && t instanceof Set ? f.set : typeof Date < "u" && t instanceof Date ? f.date : f.object;
    default:
      return f.unknown;
  }
}, d = A.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of"
]);
class re extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const n = e || function(i) {
      return i.message;
    }, r = { _errors: [] }, s = (i) => {
      for (const o of i.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(s);
        else if (o.code === "invalid_return_type")
          s(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          s(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let a = r, c = 0;
          for (; c < o.path.length; ) {
            const u = o.path[c];
            c === o.path.length - 1 ? (a[u] = a[u] || { _errors: [] }, a[u]._errors.push(n(o))) : a[u] = a[u] || { _errors: [] }, a = a[u], c++;
          }
        }
    };
    return s(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, A.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(e(s))) : r.push(e(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
re.create = (t) => new re(t);
const Ye = (t, e) => {
  let n;
  switch (t.code) {
    case d.invalid_type:
      t.received === f.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case d.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected, A.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${A.joinValues(t.keys, ", ")}`;
      break;
    case d.invalid_union:
      n = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${A.joinValues(t.options)}`;
      break;
    case d.invalid_enum_value:
      n = `Invalid enum value. Expected ${A.joinValues(t.options)}, received '${t.received}'`;
      break;
    case d.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      n = "Invalid function return type";
      break;
    case d.invalid_date:
      n = "Invalid date";
      break;
    case d.invalid_string:
      typeof t.validation == "object" ? "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : A.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case d.too_small:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be greater than ${t.inclusive ? "or equal to " : ""}${t.minimum}` : t.type === "date" ? n = `Date must be greater than ${t.inclusive ? "or equal to " : ""}${new Date(t.minimum)}` : n = "Invalid input";
      break;
    case d.too_big:
      t.type === "array" ? n = `Array must contain ${t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be less than ${t.inclusive ? "or equal to " : ""}${t.maximum}` : t.type === "date" ? n = `Date must be smaller than ${t.inclusive ? "or equal to " : ""}${new Date(t.maximum)}` : n = "Invalid input";
      break;
    case d.custom:
      n = "Invalid input";
      break;
    case d.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    default:
      n = e.defaultError, A.assertNever(t);
  }
  return { message: n };
};
let ts = Ye;
function ht() {
  return ts;
}
const pt = (t) => {
  const { data: e, path: n, errorMaps: r, issueData: s } = t, i = [...n, ...s.path || []], o = {
    ...s,
    path: i
  };
  let a = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    a = u(o, { data: e, defaultError: a }).message;
  return {
    ...s,
    path: i,
    message: s.message || a
  };
};
function h(t, e) {
  const n = pt({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      ht(),
      Ye
    ].filter((r) => !!r)
  });
  t.common.issues.push(n);
}
class M {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return v;
      s.status === "dirty" && e.dirty(), r.push(s.value);
    }
    return { status: e.value, value: r };
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const s of n)
      r.push({
        key: await s.key,
        value: await s.value
      });
    return M.mergeObjectSync(e, r);
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const s of n) {
      const { key: i, value: o } = s;
      if (i.status === "aborted" || o.status === "aborted")
        return v;
      i.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), (typeof o.value < "u" || s.alwaysSet) && (r[i.value] = o.value);
    }
    return { status: e.value, value: r };
  }
}
const v = Object.freeze({
  status: "aborted"
}), L = (t) => ({ status: "valid", value: t }), Ft = (t) => t.status === "aborted", zt = (t) => t.status === "dirty", mt = (t) => t.status === "valid", Ht = (t) => typeof Promise !== void 0 && t instanceof Promise;
var O;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(O || (O = {}));
class H {
  constructor(e, n, r, s) {
    this.parent = e, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._path.concat(this._key);
  }
}
const Kt = (t, e) => {
  if (mt(e))
    return { success: !0, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: !1, error: new re(t.common.issues) };
};
function _(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: n, required_error: r, description: s } = t;
  if (e && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (o, a) => o.code !== "invalid_type" ? { message: a.defaultError } : typeof a.data > "u" ? { message: r ?? a.defaultError } : { message: n ?? a.defaultError }, description: s };
}
class S {
  constructor(e) {
    this.spa = this.safeParseAsync, this.superRefine = this._refinement, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.default = this.default.bind(this), this.describe = this.describe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return he(e.data);
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: he(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new M(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: he(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Ht(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(e, n) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: he(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return Kt(s, i);
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(e, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: he(e)
    }, s = this._parse({ data: e, path: [], parent: r }), i = await (Ht(s) ? s : Promise.resolve(s));
    return Kt(r, i);
  }
  refine(e, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, i) => {
      const o = e(s), a = () => i.addIssue({
        code: d.custom,
        ...r(s)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (a(), !1)) : o ? !0 : (a(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((r, s) => e(r) ? !0 : (s.addIssue(typeof n == "function" ? n(r, s) : n), !1));
  }
  _refinement(e) {
    return new ie({
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  optional() {
    return Y.create(this);
  }
  nullable() {
    return Ce.create(this);
  }
  nullish() {
    return this.optional().nullable();
  }
  array() {
    return G.create(this);
  }
  promise() {
    return Ze.create(this);
  }
  or(e) {
    return Ge.create([this, e]);
  }
  and(e) {
    return Qe.create(this, e);
  }
  transform(e) {
    return new ie({
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new jn({
      innerType: this,
      defaultValue: n,
      typeName: y.ZodDefault
    });
  }
  brand() {
    return new os({
      typeName: y.ZodBranded,
      type: this,
      ..._(void 0)
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    });
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const ns = /^c[^\s-]{8,}$/i, rs = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, ss = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
class ge extends S {
  constructor() {
    super(...arguments), this._regex = (e, n, r) => this.refinement((s) => e.test(s), {
      validation: n,
      code: d.invalid_string,
      ...O.errToObj(r)
    }), this.nonempty = (e) => this.min(1, O.errToObj(e)), this.trim = () => new ge({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(e) {
    if (this._getType(e) !== f.string) {
      const i = this._getOrReturnCtx(e);
      return h(
        i,
        {
          code: d.invalid_type,
          expected: f.string,
          received: i.parsedType
        }
      ), v;
    }
    const r = new M();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), r.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: !0,
          message: i.message
        }), r.dirty());
      else if (i.kind === "email")
        ss.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "email",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "uuid")
        rs.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "uuid",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "cuid")
        ns.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "cuid",
          code: d.invalid_string,
          message: i.message
        }), r.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), h(s, {
            validation: "url",
            code: d.invalid_string,
            message: i.message
          }), r.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), h(s, {
          validation: "regex",
          code: d.invalid_string,
          message: i.message
        }), r.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), r.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), h(s, {
          code: d.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), r.dirty()) : A.assertNever(i);
    return { status: r.value, value: e.data };
  }
  _addCheck(e) {
    return new ge({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...O.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...O.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...O.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...O.errToObj(e) });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...O.errToObj(n)
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...O.errToObj(n)
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...O.errToObj(n)
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...O.errToObj(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...O.errToObj(n)
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
ge.create = (t) => new ge({
  checks: [],
  typeName: y.ZodString,
  ..._(t)
});
function is(t, e) {
  const n = (t.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, s = n > r ? n : r, i = parseInt(t.toFixed(s).replace(".", "")), o = parseInt(e.toFixed(s).replace(".", ""));
  return i % o / Math.pow(10, s);
}
class Ie extends S {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._getType(e) !== f.number) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_type,
        expected: f.number,
        received: i.parsedType
      }), v;
    }
    let r;
    const s = new M();
    for (const i of this._def.checks)
      i.kind === "int" ? A.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? is(e.data, i.value) !== 0 && (r = this._getOrReturnCtx(e, r), h(r, {
        code: d.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : A.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, O.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, O.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, O.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, O.toString(n));
  }
  setLimit(e, n, r, s) {
    return new Ie({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: r,
          message: O.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new Ie({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: O.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: O.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: O.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: O.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: O.toString(e)
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: O.toString(n)
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int");
  }
}
Ie.create = (t) => new Ie({
  checks: [],
  typeName: y.ZodNumber,
  ..._(t)
});
class yt extends S {
  _parse(e) {
    if (this._getType(e) !== f.bigint) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.bigint,
        received: r.parsedType
      }), v;
    }
    return L(e.data);
  }
}
yt.create = (t) => new yt({
  typeName: y.ZodBigInt,
  ..._(t)
});
class vt extends S {
  _parse(e) {
    if (this._getType(e) !== f.boolean) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.boolean,
        received: r.parsedType
      }), v;
    }
    return L(e.data);
  }
}
vt.create = (t) => new vt({
  typeName: y.ZodBoolean,
  ..._(t)
});
class Ue extends S {
  _parse(e) {
    if (this._getType(e) !== f.date) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_type,
        expected: f.date,
        received: i.parsedType
      }), v;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return h(i, {
        code: d.invalid_date
      }), v;
    }
    const r = new M();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), h(s, {
        code: d.too_small,
        message: i.message,
        inclusive: !0,
        minimum: i.value,
        type: "date"
      }), r.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), h(s, {
        code: d.too_big,
        message: i.message,
        inclusive: !0,
        maximum: i.value,
        type: "date"
      }), r.dirty()) : A.assertNever(i);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new Ue({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: O.toString(n)
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: O.toString(n)
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
Ue.create = (t) => new Ue({
  checks: [],
  typeName: y.ZodDate,
  ..._(t)
});
class gt extends S {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.undefined,
        received: r.parsedType
      }), v;
    }
    return L(e.data);
  }
}
gt.create = (t) => new gt({
  typeName: y.ZodUndefined,
  ..._(t)
});
class _t extends S {
  _parse(e) {
    if (this._getType(e) !== f.null) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.null,
        received: r.parsedType
      }), v;
    }
    return L(e.data);
  }
}
_t.create = (t) => new _t({
  typeName: y.ZodNull,
  ..._(t)
});
class bt extends S {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(e) {
    return L(e.data);
  }
}
bt.create = (t) => new bt({
  typeName: y.ZodAny,
  ..._(t)
});
class Ae extends S {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(e) {
    return L(e.data);
  }
}
Ae.create = (t) => new Ae({
  typeName: y.ZodUnknown,
  ..._(t)
});
class se extends S {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return h(n, {
      code: d.invalid_type,
      expected: f.never,
      received: n.parsedType
    }), v;
  }
}
se.create = (t) => new se({
  typeName: y.ZodNever,
  ..._(t)
});
class wt extends S {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.void,
        received: r.parsedType
      }), v;
    }
    return L(e.data);
  }
}
wt.create = (t) => new wt({
  typeName: y.ZodVoid,
  ..._(t)
});
class G extends S {
  _parse(e) {
    const { ctx: n, status: r } = this._processInputParams(e), s = this._def;
    if (n.parsedType !== f.array)
      return h(n, {
        code: d.invalid_type,
        expected: f.array,
        received: n.parsedType
      }), v;
    if (s.minLength !== null && n.data.length < s.minLength.value && (h(n, {
      code: d.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: !0,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (h(n, {
      code: d.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: !0,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all(n.data.map((o, a) => s.type._parseAsync(new H(n, o, n.path, a)))).then((o) => M.mergeArray(r, o));
    const i = n.data.map((o, a) => s.type._parseSync(new H(n, o, n.path, a)));
    return M.mergeArray(r, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new G({
      ...this._def,
      minLength: { value: e, message: O.toString(n) }
    });
  }
  max(e, n) {
    return new G({
      ...this._def,
      maxLength: { value: e, message: O.toString(n) }
    });
  }
  length(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
G.create = (t, e) => new G({
  type: t,
  minLength: null,
  maxLength: null,
  typeName: y.ZodArray,
  ..._(e)
});
var xt;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
  });
})(xt || (xt = {}));
const Yt = (t) => (e) => new R({
  ...t,
  shape: () => ({
    ...t.shape(),
    ...e
  })
});
function Oe(t) {
  if (t instanceof R) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = Y.create(Oe(r));
    }
    return new R({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof G ? G.create(Oe(t.element)) : t instanceof Y ? Y.create(Oe(t.unwrap())) : t instanceof Ce ? Ce.create(Oe(t.unwrap())) : t instanceof Q ? Q.create(t.items.map((e) => Oe(e))) : t;
}
class R extends S {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = Yt(this._def), this.extend = Yt(this._def);
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), n = A.objectKeys(e);
    return this._cached = { shape: e, keys: n };
  }
  _parse(e) {
    if (this._getType(e) !== f.object) {
      const u = this._getOrReturnCtx(e);
      return h(u, {
        code: d.invalid_type,
        expected: f.object,
        received: u.parsedType
      }), v;
    }
    const { status: r, ctx: s } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof se && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        o.includes(u) || a.push(u);
    const c = [];
    for (const u of o) {
      const l = i[u], g = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new H(s, g, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof se) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of a)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        a.length > 0 && (h(s, {
          code: d.unrecognized_keys,
          keys: a
        }), r.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of a) {
        const g = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new H(s, g, s.path, l)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const g = await l.key;
        u.push({
          key: g,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => M.mergeObjectSync(r, u)) : M.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return O.errToObj, new R({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var s, i, o, a;
          const c = (o = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = O.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new R({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new R({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  setKey(e, n) {
    return this.augment({ [e]: n });
  }
  merge(e) {
    return new R({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => xt.mergeShapes(this._def.shape(), e._def.shape()),
      typeName: y.ZodObject
    });
  }
  catchall(e) {
    return new R({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const n = {};
    return A.objectKeys(e).map((r) => {
      this.shape[r] && (n[r] = this.shape[r]);
    }), new R({
      ...this._def,
      shape: () => n
    });
  }
  omit(e) {
    const n = {};
    return A.objectKeys(this.shape).map((r) => {
      A.objectKeys(e).indexOf(r) === -1 && (n[r] = this.shape[r]);
    }), new R({
      ...this._def,
      shape: () => n
    });
  }
  deepPartial() {
    return Oe(this);
  }
  partial(e) {
    const n = {};
    if (e)
      return A.objectKeys(this.shape).map((r) => {
        A.objectKeys(e).indexOf(r) === -1 ? n[r] = this.shape[r] : n[r] = this.shape[r].optional();
      }), new R({
        ...this._def,
        shape: () => n
      });
    for (const r in this.shape) {
      const s = this.shape[r];
      n[r] = s.optional();
    }
    return new R({
      ...this._def,
      shape: () => n
    });
  }
  required() {
    const e = {};
    for (const n in this.shape) {
      let s = this.shape[n];
      for (; s instanceof Y; )
        s = s._def.innerType;
      e[n] = s;
    }
    return new R({
      ...this._def,
      shape: () => e
    });
  }
  keyof() {
    return Nn(A.objectKeys(this.shape));
  }
}
R.create = (t, e) => new R({
  shape: () => t,
  unknownKeys: "strip",
  catchall: se.create(),
  typeName: y.ZodObject,
  ..._(e)
});
R.strictCreate = (t, e) => new R({
  shape: () => t,
  unknownKeys: "strict",
  catchall: se.create(),
  typeName: y.ZodObject,
  ..._(e)
});
R.lazycreate = (t, e) => new R({
  shape: t,
  unknownKeys: "strip",
  catchall: se.create(),
  typeName: y.ZodObject,
  ..._(e)
});
class Ge extends S {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = this._def.options;
    function s(i) {
      for (const a of i)
        if (a.result.status === "valid")
          return a.result;
      for (const a of i)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((a) => new re(a.ctx.common.issues));
      return h(n, {
        code: d.invalid_union,
        unionErrors: o
      }), v;
    }
    if (n.common.async)
      return Promise.all(r.map(async (i) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(s);
    {
      let i;
      const o = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && o.push(u.common.issues);
      }
      if (i)
        return n.common.issues.push(...i.ctx.common.issues), i.result;
      const a = o.map((c) => new re(c));
      return h(n, {
        code: d.invalid_union,
        unionErrors: a
      }), v;
    }
  }
  get options() {
    return this._def.options;
  }
}
Ge.create = (t, e) => new Ge({
  options: t,
  typeName: y.ZodUnion,
  ..._(e)
});
class Nt extends S {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.object)
      return h(n, {
        code: d.invalid_type,
        expected: f.object,
        received: n.parsedType
      }), v;
    const r = this.discriminator, s = n.data[r], i = this.options.get(s);
    return i ? n.common.async ? i._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : i._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (h(n, {
      code: d.invalid_union_discriminator,
      options: this.validDiscriminatorValues,
      path: [r]
    }), v);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get validDiscriminatorValues() {
    return Array.from(this.options.keys());
  }
  get options() {
    return this._def.options;
  }
  static create(e, n, r) {
    const s = /* @__PURE__ */ new Map();
    try {
      n.forEach((i) => {
        const o = i.shape[e].value;
        s.set(o, i);
      });
    } catch {
      throw new Error("The discriminator value could not be extracted from all the provided schemas");
    }
    if (s.size !== n.length)
      throw new Error("Some of the discriminator values are not unique");
    return new Nt({
      typeName: y.ZodDiscriminatedUnion,
      discriminator: e,
      options: s,
      ..._(r)
    });
  }
}
function St(t, e) {
  const n = he(t), r = he(e);
  if (t === e)
    return { valid: !0, data: t };
  if (n === f.object && r === f.object) {
    const s = A.objectKeys(e), i = A.objectKeys(t).filter((a) => s.indexOf(a) !== -1), o = { ...t, ...e };
    for (const a of i) {
      const c = St(t[a], e[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (n === f.array && r === f.array) {
    if (t.length !== e.length)
      return { valid: !1 };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i], c = St(o, a);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return n === f.date && r === f.date && +t == +e ? { valid: !0, data: t } : { valid: !1 };
}
class Qe extends S {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = (i, o) => {
      if (Ft(i) || Ft(o))
        return v;
      const a = St(i.value, o.value);
      return a.valid ? ((zt(i) || zt(o)) && n.dirty(), { status: n.value, value: a.data }) : (h(r, {
        code: d.invalid_intersection_types
      }), v);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([i, o]) => s(i, o)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Qe.create = (t, e, n) => new Qe({
  left: t,
  right: e,
  typeName: y.ZodIntersection,
  ..._(n)
});
class Q extends S {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.array)
      return h(r, {
        code: d.invalid_type,
        expected: f.array,
        received: r.parsedType
      }), v;
    if (r.data.length < this._def.items.length)
      return h(r, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        type: "array"
      }), v;
    !this._def.rest && r.data.length > this._def.items.length && (h(r, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      type: "array"
    }), n.dirty());
    const i = r.data.map((o, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new H(r, o, r.path, a)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(i).then((o) => M.mergeArray(n, o)) : M.mergeArray(n, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Q({
      ...this._def,
      rest: e
    });
  }
}
Q.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Q({
    items: t,
    typeName: y.ZodTuple,
    rest: null,
    ..._(e)
  });
};
class Je extends S {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.object)
      return h(r, {
        code: d.invalid_type,
        expected: f.object,
        received: r.parsedType
      }), v;
    const s = [], i = this._def.keyType, o = this._def.valueType;
    for (const a in r.data)
      s.push({
        key: i._parse(new H(r, a, r.path, a)),
        value: o._parse(new H(r, r.data[a], r.path, a))
      });
    return r.common.async ? M.mergeObjectAsync(n, s) : M.mergeObjectSync(n, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, r) {
    return n instanceof S ? new Je({
      keyType: e,
      valueType: n,
      typeName: y.ZodRecord,
      ..._(r)
    }) : new Je({
      keyType: ge.create(),
      valueType: e,
      typeName: y.ZodRecord,
      ..._(n)
    });
  }
}
class Ot extends S {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.map)
      return h(r, {
        code: d.invalid_type,
        expected: f.map,
        received: r.parsedType
      }), v;
    const s = this._def.keyType, i = this._def.valueType, o = [...r.data.entries()].map(([a, c], u) => ({
      key: s._parse(new H(r, a, r.path, [u, "key"])),
      value: i._parse(new H(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const a = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return v;
          (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = /* @__PURE__ */ new Map();
      for (const c of o) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return v;
        (u.status === "dirty" || l.status === "dirty") && n.dirty(), a.set(u.value, l.value);
      }
      return { status: n.value, value: a };
    }
  }
}
Ot.create = (t, e, n) => new Ot({
  valueType: e,
  keyType: t,
  typeName: y.ZodMap,
  ..._(n)
});
class Re extends S {
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e);
    if (r.parsedType !== f.set)
      return h(r, {
        code: d.invalid_type,
        expected: f.set,
        received: r.parsedType
      }), v;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (h(r, {
      code: d.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: !0,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (h(r, {
      code: d.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: !0,
      message: s.maxSize.message
    }), n.dirty());
    const i = this._def.valueType;
    function o(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return v;
        l.status === "dirty" && n.dirty(), u.add(l.value);
      }
      return { status: n.value, value: u };
    }
    const a = [...r.data.values()].map((c, u) => i._parse(new H(r, c, r.path, u)));
    return r.common.async ? Promise.all(a).then((c) => o(c)) : o(a);
  }
  min(e, n) {
    return new Re({
      ...this._def,
      minSize: { value: e, message: O.toString(n) }
    });
  }
  max(e, n) {
    return new Re({
      ...this._def,
      maxSize: { value: e, message: O.toString(n) }
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
Re.create = (t, e) => new Re({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: y.ZodSet,
  ..._(e)
});
class Le extends S {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.function)
      return h(n, {
        code: d.invalid_type,
        expected: f.function,
        received: n.parsedType
      }), v;
    function r(a, c) {
      return pt({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          ht(),
          Ye
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(a, c) {
      return pt({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          ht(),
          Ye
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: n.common.contextualErrorMap }, o = n.data;
    return this._def.returns instanceof Ze ? L(async (...a) => {
      const c = new re([]), u = await this._def.args.parseAsync(a, i).catch((m) => {
        throw c.addIssue(r(a, m)), c;
      }), l = await o(...u);
      return await this._def.returns._def.type.parseAsync(l, i).catch((m) => {
        throw c.addIssue(s(l, m)), c;
      });
    }) : L((...a) => {
      const c = this._def.args.safeParse(a, i);
      if (!c.success)
        throw new re([r(a, c.error)]);
      const u = o(...c.data), l = this._def.returns.safeParse(u, i);
      if (!l.success)
        throw new re([s(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new Le({
      ...this._def,
      args: Q.create(e).rest(Ae.create())
    });
  }
  returns(e) {
    return new Le({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, r) {
    return new Le({
      args: e || Q.create([]).rest(Ae.create()),
      returns: n || Ae.create(),
      typeName: y.ZodFunction,
      ..._(r)
    });
  }
}
class Tt extends S {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Tt.create = (t, e) => new Tt({
  getter: t,
  typeName: y.ZodLazy,
  ..._(e)
});
class Et extends S {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_literal,
        expected: this._def.value
      }), v;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
}
Et.create = (t, e) => new Et({
  value: t,
  typeName: y.ZodLiteral,
  ..._(e)
});
function Nn(t, e) {
  return new jt({
    values: t,
    typeName: y.ZodEnum,
    ..._(e)
  });
}
class jt extends S {
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return h(n, {
        expected: A.joinValues(r),
        received: n.parsedType,
        code: d.invalid_type
      }), v;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e), r = this._def.values;
      return h(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: r
      }), v;
    }
    return L(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values)
      e[n] = n;
    return e;
  }
}
jt.create = Nn;
class At extends S {
  _parse(e) {
    const n = A.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);
    if (r.parsedType !== f.string && r.parsedType !== f.number) {
      const s = A.objectValues(n);
      return h(r, {
        expected: A.joinValues(s),
        received: r.parsedType,
        code: d.invalid_type
      }), v;
    }
    if (n.indexOf(e.data) === -1) {
      const s = A.objectValues(n);
      return h(r, {
        received: r.data,
        code: d.invalid_enum_value,
        options: s
      }), v;
    }
    return L(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
At.create = (t, e) => new At({
  values: t,
  typeName: y.ZodNativeEnum,
  ..._(e)
});
class Ze extends S {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.promise && n.common.async === !1)
      return h(n, {
        code: d.invalid_type,
        expected: f.promise,
        received: n.parsedType
      }), v;
    const r = n.parsedType === f.promise ? n.data : Promise.resolve(n.data);
    return L(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Ze.create = (t, e) => new Ze({
  type: t,
  typeName: y.ZodPromise,
  ..._(e)
});
class ie extends S {
  innerType() {
    return this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: r } = this._processInputParams(e), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const o = s.transform(r.data);
      return r.common.async ? Promise.resolve(o).then((a) => this._def.schema._parseAsync({
        data: a,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: o,
        path: r.path,
        parent: r
      });
    }
    const i = {
      addIssue: (o) => {
        h(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "refinement") {
      const o = (a) => {
        const c = s.refinement(a, i);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? v : (a.status === "dirty" && n.dirty(), o(a.value), { status: n.value, value: a.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => a.status === "aborted" ? v : (a.status === "dirty" && n.dirty(), o(a.value).then(() => ({ status: n.value, value: a.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!mt(o))
          return o;
        const a = s.transform(o.value, i);
        if (a instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: a };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => mt(o) ? Promise.resolve(s.transform(o.value, i)).then((a) => ({ status: n.value, value: a })) : o);
    A.assertNever(s);
  }
}
ie.create = (t, e, n) => new ie({
  schema: t,
  typeName: y.ZodEffects,
  effect: e,
  ..._(n)
});
ie.createWithPreprocess = (t, e, n) => new ie({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: y.ZodEffects,
  ..._(n)
});
class Y extends S {
  _parse(e) {
    return this._getType(e) === f.undefined ? L(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Y.create = (t, e) => new Y({
  innerType: t,
  typeName: y.ZodOptional,
  ..._(e)
});
class Ce extends S {
  _parse(e) {
    return this._getType(e) === f.null ? L(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ce.create = (t, e) => new Ce({
  innerType: t,
  typeName: y.ZodNullable,
  ..._(e)
});
class jn extends S {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === f.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
jn.create = (t, e) => new Y({
  innerType: t,
  typeName: y.ZodOptional,
  ..._(e)
});
class kt extends S {
  _parse(e) {
    if (this._getType(e) !== f.nan) {
      const r = this._getOrReturnCtx(e);
      return h(r, {
        code: d.invalid_type,
        expected: f.nan,
        received: r.parsedType
      }), v;
    }
    return { status: "valid", value: e.data };
  }
}
kt.create = (t) => new kt({
  typeName: y.ZodNaN,
  ..._(t)
});
class os extends S {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
R.lazycreate;
var y;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded";
})(y || (y = {}));
const I = ge.create, et = Ie.create;
kt.create;
yt.create;
const Mn = vt.create;
Ue.create;
gt.create;
_t.create;
bt.create;
Ae.create;
se.create;
wt.create;
G.create;
const T = R.create;
R.strictCreate;
const D = Ge.create;
Nt.create;
Qe.create;
Q.create;
Je.create;
Ot.create;
Re.create;
Le.create;
Tt.create;
const w = Et.create;
jt.create;
At.create;
Ze.create;
ie.create;
Y.create;
Ce.create;
ie.createWithPreprocess;
const we = {
  oneTimeAccounts: w("oneTimeAccounts"),
  ongoingAccounts: w("ongoingAccounts"),
  oneTimePersonaData: w("oneTimePersonaData"),
  ongoingPersonaData: w("ongoingPersonaData"),
  auth: w("auth"),
  send: w("send")
}, as = D([
  w("rejectedByUser"),
  w("wrongNetwork"),
  w("failedToPrepareTransaction"),
  w("failedToCompileTransaction"),
  w("failedToSignTransaction"),
  w("failedToSubmitTransaction"),
  w("failedToPollSubmittedTransaction"),
  w("failedToFindAccountWithEnoughFundsToLockFee"),
  w("submittedTransactionWasDuplicate"),
  w("submittedTransactionHasFailedTransactionStatus"),
  w("submittedTransactionHasRejectedTransactionStatus")
]), Mt = T({
  address: I(),
  label: I(),
  appearanceId: et()
}), Ln = T({
  account: Mt,
  challenge: I(),
  signature: I()
}), Lt = T({
  identityAddress: I(),
  label: I()
}), Un = T({
  field: I(),
  value: I()
});
D([
  w("exactly"),
  w("atLeast")
]);
const Zn = T({
  quantifier: D([w("exactly"), w("atLeast")]),
  quantity: et()
}), us = T({
  networkId: et(),
  dAppDefinitionAddress: I()
}), Dn = T({
  requiresProofOfOwnership: Mn(),
  numberOfAccounts: Zn
}), cs = T({
  accounts: Ln.array()
}), ls = T({
  accounts: Mt.array()
}), Wn = D([
  cs,
  ls
]), ds = T({
  requiresProofOfOwnership: Mn(),
  numberOfAccounts: Zn
}), fs = T({
  accounts: Ln.array()
}), hs = T({
  accounts: Mt.array()
}), ps = D([
  fs,
  hs
]), qn = T({
  fields: I().array()
}), Bn = T({
  fields: Un.array()
}), ms = T({
  fields: I().array()
}), ys = T({
  fields: Un.array()
}), vs = T({
  discriminator: w("usePersona"),
  identityAddress: I()
}), gs = T({
  discriminator: w("usePersona"),
  persona: Lt
}), _s = T({
  discriminator: w("login"),
  challenge: I().optional()
}), bs = T({
  discriminator: w("loginWithoutChallenge"),
  persona: Lt
}), ws = T({
  discriminator: w("loginWithChallenge"),
  persona: Lt,
  challenge: I(),
  publicKey: I(),
  signature: I()
}), xs = D([
  bs,
  ws
]), Ss = D([
  vs,
  _s
]), Os = D([
  gs,
  xs
]), Ts = T({
  transactionManifest: I(),
  version: et(),
  blobs: I().array().optional(),
  message: I().optional()
}), Es = T({
  transactionIntentHash: I()
}), As = T({
  discriminator: w("unauthorizedRequest"),
  oneTimeAccounts: Dn.optional(),
  oneTimePersonaData: qn.optional()
}), ks = T({
  discriminator: w("authorizedRequest"),
  auth: Ss,
  oneTimeAccounts: Dn.optional(),
  ongoingAccounts: ds.optional(),
  oneTimePersonaData: qn.optional(),
  ongoingPersonaData: ms.optional()
}), Ps = D([
  As,
  ks
]), Is = T({
  discriminator: w("transaction"),
  send: Ts
}), Rs = D([
  Ps,
  Is
]), Cs = T({
  interactionId: I(),
  items: Rs,
  metadata: us
}), $s = T({
  discriminator: w("unauthorizedRequest"),
  oneTimeAccounts: Wn.optional(),
  oneTimePersonaData: Bn.optional()
}), Ns = T({
  discriminator: w("authorizedRequest"),
  auth: Os,
  oneTimeAccounts: Wn.optional(),
  ongoingAccounts: ps.optional(),
  oneTimePersonaData: Bn.optional(),
  ongoingPersonaData: ys.optional()
}), js = D([
  $s,
  Ns
]), Ms = T({
  discriminator: w("transaction"),
  send: Es
}), Ls = D([
  js,
  Ms
]), Us = T({
  discriminator: w("success"),
  interactionId: I(),
  items: Ls
}), Zs = T({
  discriminator: w("failure"),
  interactionId: I(),
  error: as,
  message: I().optional()
}), Ds = D([
  Us,
  Zs
]), Gt = (t) => J.fromPromise(
  Cs.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr((e) => (W.error("ðŸ”µðŸ’¥ invalid wallet request"), W.debug(JSON.stringify(t, null, 2)), W.debug(JSON.stringify(e, null, 2)), Ke(
  me.walletRequestValidation,
  t.interactionId
))), Qt = (t) => J.fromPromise(
  Ds.parseAsync(t),
  (e) => e.issues
).map(() => t).mapErr(() => (W.error("ðŸ”µðŸ’¥ invalid wallet response"), Ke(
  me.walletRequestValidation,
  t.interactionId
))), Jt = (t) => {
  const { discriminator: e, ...n } = t;
  return Object.entries(n).reduce((r, [s, i]) => {
    switch (s) {
      case we.auth.value: {
        const { discriminator: o, ...a } = i;
        if (o === "usePersona")
          return { ...r, persona: a.persona };
        if (o === "loginWithChallenge") {
          const { persona: c, ...u } = a;
          return { ...r, persona: c, signedChallenge: u };
        } else
          return { ...r, persona: a.persona };
      }
      case we.oneTimeAccounts.value:
        return { ...r, oneTimeAccounts: i.accounts };
      case we.ongoingAccounts.value:
        return { ...r, ongoingAccounts: i.accounts };
      case we.oneTimePersonaData.value:
        return { ...r, oneTimePersonaData: i.fields };
      case we.ongoingPersonaData.value:
        return { ...r, ongoingPersonaData: i.fields };
      case we.send.value:
        return { ...r, transactionIntentHash: i.transactionIntentHash };
      default:
        return r;
    }
  }, {});
}, ee = {
  oneTimeAccountsWithoutProofOfOwnership: "oneTimeAccountsWithoutProofOfOwnership",
  oneTimeAccountsWithProofOfOwnership: "oneTimeAccountsWithProofOfOwnership",
  ongoingAccountsWithoutProofOfOwnership: "ongoingAccountsWithoutProofOfOwnership",
  ongoingAccountsWithProofOfOwnership: "ongoingAccountsWithProofOfOwnership",
  usePersona: "usePersona",
  loginWithoutChallenge: "loginWithoutChallenge",
  loginWithChallenge: "loginWithChallenge",
  login: "login",
  oneTimePersonaData: "oneTimePersonaData",
  ongoingPersonaData: "ongoingPersonaData"
}, Be = (t) => ({
  quantity: (t == null ? void 0 : t.quantity) || 1,
  quantifier: (t == null ? void 0 : t.quantifier) || "atLeast"
}), Xt = (t) => V(
  Object.entries(t).reduce(
    (e, [n, r]) => {
      switch (n) {
        case ee.oneTimeAccountsWithoutProofOfOwnership:
          return {
            ...e,
            oneTimeAccounts: {
              requiresProofOfOwnership: !1,
              numberOfAccounts: Be(r)
            }
          };
        case ee.oneTimeAccountsWithProofOfOwnership:
          return {
            ...e,
            oneTimeAccounts: {
              requiresProofOfOwnership: !0,
              numberOfAccounts: Be(r)
            }
          };
        case ee.ongoingAccountsWithProofOfOwnership:
          return {
            ...e,
            ongoingAccounts: {
              requiresProofOfOwnership: !0,
              numberOfAccounts: Be(r)
            }
          };
        case ee.ongoingAccountsWithoutProofOfOwnership:
          return {
            ...e,
            ongoingAccounts: {
              requiresProofOfOwnership: !1,
              numberOfAccounts: Be(r)
            }
          };
        case ee.loginWithoutChallenge:
          return {
            ...e,
            auth: { ...r, discriminator: "login" },
            discriminator: "authorizedRequest"
          };
        case ee.usePersona:
          return {
            ...e,
            auth: { ...r, discriminator: "usePersona" },
            discriminator: "authorizedRequest"
          };
        case ee.loginWithChallenge:
          return {
            ...e,
            auth: r,
            discriminator: "authorizedRequest"
          };
        case "send":
          return {
            discriminator: "transaction",
            send: r
          };
        default:
          return {
            ...e,
            [n]: r
          };
      }
    },
    {
      discriminator: "unauthorizedRequest"
    }
  )
), en = (t) => (e, n = crypto.randomUUID()) => V({
  items: e,
  interactionId: n,
  metadata: t
}), Ws = {
  send: "send"
}, qs = {
  ...ee,
  ...Ws
}, Bs = (t, e) => ({
  request: (s, i = {}) => Xt(s).andThen(en(t)).asyncAndThen(Gt).andThen(e(i)).andThen(Qt).map((o) => o.items).map(Jt),
  sendTransaction: (s, i = {}) => Xt({ [qs.send]: s }).andThen(en(t)).asyncAndThen(Gt).andThen(e(i)).andThen(Qt).map((o) => o.items).map(Jt)
});
var Vs = /* @__PURE__ */ ((t) => (t.I8 = "i8", t.I16 = "i16", t.I32 = "i32", t.I64 = "i64", t.I128 = "i128", t.U8 = "u8", t.U16 = "u16", t.U32 = "u32", t.U64 = "u64", t.U128 = "u128", t.Unit = "Unit", t.Bool = "Bool", t.String = "String", t.Enum = "Enum", t.Array = "Array", t.Tuple = "Tuple", t.PackageAddress = "PackageAddress", t.ComponentAddress = "ComponentAddress", t.ResourceAddress = "ResourceAddress", t.SystemAddress = "SystemAddress", t.Bucket = "Bucket", t.Proof = "Proof", t.Expression = "Expression", t.Blob = "Blob", t.NonFungibleAddress = "NonFungibleAddress", t.Hash = "Hash", t.EcdsaSecp256k1PublicKey = "EcdsaSecp256k1PublicKey", t.EcdsaSecp256k1Signature = "EcdsaSecp256k1Signature", t.EddsaEd25519PublicKey = "EddsaEd25519PublicKey", t.EddsaEd25519Signature = "EddsaEd25519Signature", t.Decimal = "Decimal", t.PreciseDecimal = "PreciseDecimal", t.NonFungibleId = "NonFungibleId", t))(Vs || {});
class U extends Error {
  constructor(e) {
    super(e);
  }
}
const Ai = () => "()", ki = (t) => `${t}`, Pi = (t) => {
  if (t < -128 || t > 127)
    throw new U("Number range exceeded i8");
  return `${t}i8`;
}, Ii = (t) => {
  if (t < -32768 || t > 32767)
    throw new U("Number range exceeded i16");
  return `${t}i16`;
}, Ri = (t) => {
  if (t < -2147483648 || t > 2147483647)
    throw new U("Number range exceeded i32");
  return `${t}i32`;
}, Ci = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-9223372036854775808") || e > BigInt("9223372036854775807"))
    throw new U("Number range exceeded i64");
  return `${t}i64`;
}, $i = (t) => {
  const e = BigInt(t);
  if (e < BigInt("-170141183460469231731687303715884105728") || e > BigInt("170141183460469231731687303715884105727"))
    throw new U("Number range exceeded i128");
  return `${t}i128`;
}, Ni = (t) => {
  if (t < 0 || t > 255)
    throw new U("Number range exceeded u8");
  return `${t}u8`;
}, ji = (t) => {
  if (t < 0 || t > 65535)
    throw new U("Number range exceeded u16");
  return `${t}u16`;
}, Mi = (t) => {
  if (t < 0 || t > 4294967295)
    throw new U("Number range exceeded u32");
  return `${t}u32`;
}, Li = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("18446744073709551615"))
    throw new U("Number range exceeded u64");
  return `${t}u64`;
}, Ui = (t) => {
  const e = BigInt(t);
  if (e < 0 || e > BigInt("340282366920938463463374607431768211455"))
    throw new U("Number range exceeded u128");
  return `${t}u128`;
}, Zi = (t) => `"${t}"`, Di = (t, ...e) => e.length > 0 ? `Enum("${t}",${e.join(",")})` : `Enum("${t}")`, Wi = (...t) => `Tuple(${t.join(",")})`, qi = (t, ...e) => (zs(t, e), `Array<${t}>(${e.join(",")})`), Fs = (t) => `PackageAddress("${t}")`, le = (t) => `ComponentAddress("${t}")`, N = (t) => `ResourceAddress("${t}")`, Bi = (t) => `SystemAddress("${t}")`, xe = (t) => typeof t == "string" ? `Bucket("${t}")` : `Bucket(${t}u32)`, K = (t) => typeof t == "string" ? `Proof("${t}")` : `Proof(${t}u32)`, Vi = (t) => `Expression("${t}")`, Fi = (t) => `Blob("${t}")`, zi = (t, e) => `NonFungibleAddress("${t}", ${e})`, Hi = (t) => `Hash("${t}")`, Ki = (t) => `EcdsaSecp256k1PublicKey("${t}")`, Yi = (t) => `EcdsaSecp256k1Signature("${t}")`, Gi = (t) => `EddsaEd25519PublicKey("${t}")`, Qi = (t) => `EddsaEd25519Signature("${t}")`, Se = (t) => `Decimal("${t}")`, Ji = (t) => `PreciseDecimal("${t}")`, Xi = (t) => `NonFungibleId(${t})`, zs = (t, e) => {
  if (t === "String") {
    if (e.some((n) => !n.startsWith('"') && !n.endsWith('"')))
      throw new U(`Array<${t}> expects the same type`);
  } else if (t === "Unit") {
    if (e.some((n) => n !== "()"))
      throw new U(`Array<${t}> expects the same type`);
  } else if (e.some((n) => !n.includes(t)))
    throw new U(`Array<${t}> expects the same type`);
};
class Hs {
  constructor(e) {
    be(this, "instructions");
    this.instructions = e;
  }
  toString() {
    return this.instructions.join(`
`);
  }
}
class eo {
  constructor() {
    be(this, "instructions");
    be(this, "buckets");
    be(this, "proofs");
    be(this, "id_allocator");
    this.instructions = [], this.buckets = /* @__PURE__ */ new Map(), this.proofs = /* @__PURE__ */ new Map(), this.id_allocator = 512;
  }
  takeFromWorktop(e, n) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP ${N(e)} ${xe(
        n
      )};`
    ), this.buckets.set(n, this.id_allocator++), this;
  }
  takeFromWorktopByAmount(e, n, r) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_AMOUNT ${Se(e)} ${N(
        n
      )} ${xe(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  takeFromWorktopByIds(e, n, r) {
    return this.instructions.push(
      `TAKE_FROM_WORKTOP_BY_IDS ${e} ${N(
        n
      )} ${xe(r)};`
    ), this.buckets.set(r, this.id_allocator++), this;
  }
  returnToWorktop(e) {
    return this.instructions.push(`RETURN_TO_WORKTOP ${xe(e)};`), this;
  }
  assertWorktopContains(e) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS ${N(e)};`
    ), this;
  }
  assertWorktopContainsByAmount(e, n) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_AMOUNT ${Se(e)} ${N(
        n
      )};`
    ), this;
  }
  assertWorktopContainsByIds(e, n) {
    return this.instructions.push(
      `ASSERT_WORKTOP_CONTAINS_BY_IDS ${e} ${N(
        n
      )};`
    ), this;
  }
  popFromAuthZone(e) {
    return this.instructions.push(`POP_FROM_AUTH_ZONE ${K(e)};`), this.proofs.set(e, this.id_allocator++), this;
  }
  pushToAuthZone(e) {
    return this.instructions.push(`PUSH_TO_AUTH_ZONE ${K(e)};`), this;
  }
  clearAuthZone() {
    return this.instructions.push("CLEAR_AUTH_ZONE;"), this;
  }
  createProofFromAuthZone(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE ${N(e)} ${K(
        n
      )};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  createProofFromAuthZoneByAmount(e, n, r) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_AMOUNT ${Se(
        e
      )} ${N(n)} ${K(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromAuthZoneByIds(e, n, r) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_AUTH_ZONE_BY_IDS ${e} ${N(
        n
      )} ${K(r)};`
    ), this.proofs.set(r, this.id_allocator++), this;
  }
  createProofFromBucket(e, n) {
    return this.instructions.push(
      `CREATE_PROOF_FROM_BUCKET ${xe(e)} ${K(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  cloneProof(e, n) {
    return this.instructions.push(
      `CLONE_PROOF ${K(e)} ${K(n)};`
    ), this.proofs.set(n, this.id_allocator++), this;
  }
  dropProof(e) {
    return this.instructions.push(`DROP_PROOF ${K(e)};`), this;
  }
  callFunction(e, n, r, s) {
    return this.instructions.push(
      `CALL_FUNCTION ${Fs(
        e
      )} "${n}" "${r}" ${s.join(" ")};`
    ), this;
  }
  callMethod(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${le(
        e
      )} "${n}" ${r.join(" ")};`
    ), this;
  }
  callNativeFunction(e, n, r) {
    return this.instructions.push(
      'CALL_NATIVE_FUNCTION "' + e + '" "' + n + '" ' + r.join(" ") + ";"
    ), this;
  }
  callNativeMethod(e, n, r) {
    return this.instructions.push(
      "CALL_NATIVE_METHOD " + e + ' "' + n + '" ' + r.join(" ") + ";"
    ), this;
  }
  publishPackageWithOwner(e, n, r) {
    return this.instructions.push(
      'PUBLISH_PACKAGE_WITH_OWNER Blob("' + e + '") Blob("' + n + '") ' + r + ";"
    ), this;
  }
  createResource(e, n, r, s) {
    return this.instructions.push(
      `CREATE_RESOURCE ${e} ${n} ${r} ${s};`
    ), this;
  }
  burnBucket(e) {
    return this.instructions.push(`BURN_BUCKET ${xe(e)};`), this;
  }
  mintFungible(e, n) {
    return this.instructions.push(
      `MINT_FUNGIBLE ${N(e)} ${Se(n)};`
    ), this;
  }
  withdrawFromAccount(e, n) {
    return this.instructions.push(
      `CALL_METHOD ${le(
        e
      )} "withdraw" ${N(n)};`
    ), this;
  }
  withdrawFromAccountByAmount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${le(
        e
      )} "withdraw_by_amount" ${Se(n)} ${N(
        r
      )};`
    ), this;
  }
  withdrawFromAccountByIds(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${le(
        e
      )} "withdraw_by_ids" ${n} ${N(
        r
      )};`
    ), this;
  }
  createProofFromAccount(e, n) {
    return this.instructions.push(
      `CALL_METHOD ${le(
        e
      )} "create_proof" ${N(n)};`
    ), this;
  }
  createProofFromAccountByAmount(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${le(
        e
      )} "create_proof_by_amount" ${Se(n)} ${N(
        r
      )};`
    ), this;
  }
  createProofFromAccountByIds(e, n, r) {
    return this.instructions.push(
      `CALL_METHOD ${le(
        e
      )} "create_proof_by_ids" ${n} ${N(
        r
      )};`
    ), this;
  }
  build() {
    return new Hs(this.instructions);
  }
}
var Ks = "Expected a function", Ys = 9007199254740991, Gs = "[object Arguments]", Qs = "[object Function]", Js = "[object GeneratorFunction]", Xs = typeof Ne == "object" && Ne && Ne.Object === Object && Ne, ei = typeof self == "object" && self && self.Object === Object && self, ti = Xs || ei || Function("return this")();
function ni(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
function ri(t, e) {
  for (var n = -1, r = e.length, s = t.length; ++n < r; )
    t[s + n] = e[n];
  return t;
}
var Ut = Object.prototype, si = Ut.hasOwnProperty, Vn = Ut.toString, tn = ti.Symbol, ii = Ut.propertyIsEnumerable, nn = tn ? tn.isConcatSpreadable : void 0, rn = Math.max;
function Fn(t, e, n, r, s) {
  var i = -1, o = t.length;
  for (n || (n = ui), s || (s = []); ++i < o; ) {
    var a = t[i];
    e > 0 && n(a) ? e > 1 ? Fn(a, e - 1, n, r, s) : ri(s, a) : r || (s[s.length] = a);
  }
  return s;
}
function oi(t, e) {
  return e = rn(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, r = -1, s = rn(n.length - e, 0), i = Array(s); ++r < s; )
      i[r] = n[e + r];
    r = -1;
    for (var o = Array(e + 1); ++r < e; )
      o[r] = n[r];
    return o[e] = i, ni(t, this, o);
  };
}
function ai(t) {
  return oi(function(e) {
    e = Fn(e, 1);
    var n = e.length, r = n;
    for (t && e.reverse(); r--; )
      if (typeof e[r] != "function")
        throw new TypeError(Ks);
    return function() {
      for (var s = 0, i = n ? e[s].apply(this, arguments) : arguments[0]; ++s < n; )
        i = e[s].call(this, i);
      return i;
    };
  });
}
function ui(t) {
  return li(t) || ci(t) || !!(nn && t && t[nn]);
}
function ci(t) {
  return fi(t) && si.call(t, "callee") && (!ii.call(t, "callee") || Vn.call(t) == Gs);
}
var li = Array.isArray;
function di(t) {
  return t != null && pi(t.length) && !hi(t);
}
function fi(t) {
  return yi(t) && di(t);
}
function hi(t) {
  var e = mi(t) ? Vn.call(t) : "";
  return e == Qs || e == Js;
}
function pi(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Ys;
}
function mi(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function yi(t) {
  return !!t && typeof t == "object";
}
var vi = ai(), gi = vi;
function to(...t) {
  return gi(t)({});
}
const _i = {
  withoutChallenge: () => (t) => ({
    ...t,
    loginWithoutChallenge: {
      discriminator: "login"
    }
  }),
  withChallenge: (t) => (e) => ({
    ...e,
    loginWithChallenge: { discriminator: "login", challenge: t }
  })
}, bi = {
  withoutProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    oneTimeAccountsWithoutProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  }),
  withProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    oneTimeAccountsWithProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  })
}, wi = (...t) => (e) => ({
  ...e,
  oneTimePersonaData: { fields: t }
}), xi = {
  withoutProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    ongoingAccountsWithoutProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  }),
  withProofOfOwnership: (t = B.defaultNumberOfAccountsQuantity, e = B.defaultNumberOfAccountsQuantifier) => (n) => ({
    ...n,
    ongoingAccountsWithProofOfOwnership: {
      quantity: t,
      quantifier: e
    }
  })
}, Si = (...t) => (e) => ({
  ...e,
  ongoingPersonaData: { fields: t }
}), Oi = (t) => (e) => ({
  ...e,
  usePersona: { discriminator: "usePersona", identityAddress: t }
}), no = {
  oneTimeAccounts: bi,
  ongoingAccounts: xi,
  oneTimePersonaData: wi,
  ongoingPersonaData: Si,
  login: _i,
  usePersona: Oi
}, Ti = {
  Mainnet: 1,
  Stokenet: 2,
  Adapanet: 10,
  Nebunet: 11,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34
}, ro = ({
  networkId: t = Ti.Mainnet,
  dAppDefinitionAddress: e,
  logLevel: n = B.logLevel
}) => {
  W.setLevel(n), W.debug("ðŸ”µ wallet sdk instantiated");
  const r = Fr(), s = () => {
    W.debug("ðŸ”µðŸ§¹ destroying wallet sdk instance"), r.destroy();
  };
  return {
    ...Bs(
      { networkId: t, dAppDefinitionAddress: e },
      es(r.subjects)
    ),
    destroy: s,
    __subjects: r.subjects
  };
};
export {
  qi as Array,
  xs as AuthLoginRequestResponseItemSchema,
  Ss as AuthRequestItemSchema,
  Fi as Blob,
  ki as Bool,
  xe as Bucket,
  le as ComponentAddress,
  Se as Decimal,
  Ki as EcdsaSecp256k1PublicKey,
  Yi as EcdsaSecp256k1Signature,
  Gi as EddsaEd25519PublicKey,
  Qi as EddsaEd25519Signature,
  Di as Enum,
  as as ErrorTypeSchema,
  Vi as Expression,
  Hi as Hash,
  $i as I128,
  Ii as I16,
  Ri as I32,
  Ci as I64,
  Pi as I8,
  eo as ManifestBuilder,
  Ti as Network,
  zi as NonFungibleAddress,
  Xi as NonFungibleId,
  Wn as OneTimeAccountsRequestResponseItemSchema,
  Fs as PackageAddress,
  Ji as PreciseDecimal,
  K as Proof,
  we as RequestTypeSchema,
  N as ResourceAddress,
  U as ScryptoValueError,
  Zi as String,
  Bi as SystemAddress,
  Wi as Tuple,
  Vs as TypeId,
  Ui as U128,
  ji as U16,
  Mi as U32,
  Li as U64,
  Ni as U8,
  Ai as Unit,
  Ns as WalletAuthorizedRequestResponseItemsSchema,
  Zs as WalletInteractionFailureResponseSchema,
  Ls as WalletInteractionResponseItemsSchema,
  Ds as WalletInteractionResponseSchema,
  Cs as WalletInteractionSchema,
  Us as WalletInteractionSuccessResponseSchema,
  Ps as WalletRequestItemsSchema,
  js as WalletRequestResponseItemsSchema,
  ro as WalletSdk,
  Ms as WalletTransactionResponseItemsSchema,
  $s as WalletUnauthorizedRequestResponseItemsSchema,
  Ke as createSdkError,
  me as errorType,
  _i as login,
  bi as oneTimeAccounts,
  wi as oneTimePersonaData,
  xi as ongoingAccounts,
  Si as ongoingPersonaData,
  to as requestBuilder,
  no as requestItem,
  Gr as sdkError,
  Oi as usePersona
};
