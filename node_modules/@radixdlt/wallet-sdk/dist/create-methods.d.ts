import { ResultAsync } from 'neverthrow';
import { SdkError } from './helpers/error';
import { Metadata, WalletInteraction, WalletInteractionSuccessResponse } from './IO/schemas';
import { CallbackFns } from './messages/events/_types';
import { Method } from './_types';
type SendWalletInteraction = (callbackFns: Partial<CallbackFns>) => (message: WalletInteraction) => ResultAsync<WalletInteractionSuccessResponse, SdkError>;
export declare const createMethods: (metadata: Metadata, sendMessageToWallet: SendWalletInteraction) => {
    request: <Input extends Partial<{
        oneTimeAccountsWithoutProofOfOwnership: {
            quantity?: number | undefined;
            quantifier?: "exactly" | "atLeast" | undefined;
        };
        oneTimeAccountsWithProofOfOwnership: {
            quantity?: number | undefined;
            quantifier?: "exactly" | "atLeast" | undefined;
        };
        ongoingAccountsWithoutProofOfOwnership: {
            quantity: number;
            quantifier: "exactly" | "atLeast";
        };
        ongoingAccountsWithProofOfOwnership: {
            quantity: number;
            quantifier: "exactly" | "atLeast";
        };
        usePersona: {
            identityAddress: string;
        };
        loginWithoutChallenge: {};
        loginWithChallenge: {
            challenge: string;
        };
        login: {};
        oneTimePersonaData: {
            fields: string[];
        };
        ongoingPersonaData: {
            fields: string[];
        };
    }>, Output extends keyof Input extends keyof {
        oneTimeAccountsWithoutProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
            method: {
                input: {
                    quantity?: number | undefined;
                    quantifier?: "exactly" | "atLeast" | undefined;
                };
                output: {
                    oneTimeAccounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
        };
        oneTimeAccountsWithProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
            method: {
                input: {
                    quantity?: number | undefined;
                    quantifier?: "exactly" | "atLeast" | undefined;
                };
                output: {
                    oneTimeAccounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
        };
        ongoingAccountsWithoutProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
            method: {
                input: {
                    quantity: number;
                    quantifier: "exactly" | "atLeast";
                };
                output: {
                    ongoingAccounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
        };
        ongoingAccountsWithProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
            method: {
                input: {
                    quantity: number;
                    quantifier: "exactly" | "atLeast";
                };
                output: {
                    ongoingAccounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
        };
        usePersona: import("./wallet-sdk").UsePersona;
        loginWithoutChallenge: {
            wallet: {
                request: {
                    challenge?: string | undefined;
                    discriminator: "login";
                };
                response: {
                    discriminator: "loginWithoutChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
            method: {
                input: {};
                output: {
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
        };
        loginWithChallenge: {
            wallet: {
                request: {
                    challenge?: string | undefined;
                    discriminator: "login";
                };
                response: {
                    challenge: string;
                    signature: string;
                    discriminator: "loginWithChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                    publicKey: string;
                };
            };
            method: {
                output: {
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                    signedChallenge: {
                        challenge: string;
                        publicKey: string;
                        signature: string;
                    };
                };
                input: {
                    challenge: string;
                };
            };
        };
        login: {
            wallet: {
                request: {
                    challenge?: string | undefined;
                    discriminator: "login";
                };
                response: {
                    discriminator: "loginWithoutChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
            method: {
                input: {};
                output: {
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
        };
        oneTimePersonaData: import("./wallet-sdk").OneTimePersonaData;
        ongoingPersonaData: import("./wallet-sdk").OngoingPersonaData;
    } ? { [Key in keyof Input]: (x: {
        oneTimePersonaData: {
            oneTimePersonaData: {
                value: string;
                field: string;
            }[];
        };
        ongoingPersonaData: {
            ongoingPersonaData: {
                value: string;
                field: string;
            }[];
        };
        usePersona: {
            persona: {
                label: string;
                identityAddress: string;
            };
        };
        login: {
            persona: {
                label: string;
                identityAddress: string;
            };
        };
        loginWithoutChallenge: {
            persona: {
                label: string;
                identityAddress: string;
            };
        };
        loginWithChallenge: {
            persona: {
                label: string;
                identityAddress: string;
            };
            signedChallenge: {
                challenge: string;
                publicKey: string;
                signature: string;
            };
        };
        oneTimeAccountsWithProofOfOwnership: {
            oneTimeAccounts: {
                account: {
                    address: string;
                    label: string;
                    appearanceId: number;
                };
                challenge: string;
                signature: string;
            }[];
        };
        oneTimeAccountsWithoutProofOfOwnership: {
            oneTimeAccounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
        };
        ongoingAccountsWithProofOfOwnership: {
            ongoingAccounts: {
                account: {
                    address: string;
                    label: string;
                    appearanceId: number;
                };
                challenge: string;
                signature: string;
            }[];
        };
        ongoingAccountsWithoutProofOfOwnership: {
            ongoingAccounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
        };
    }[Key]) => void; }[keyof Input] extends (x: infer T) => void ? T : never : never>(input: Input, callbackFns?: Partial<CallbackFns>) => ResultAsync<Output, SdkError>;
    sendTransaction: (input: Method['sendTransaction']['input'], callbackFns?: Partial<CallbackFns>) => ResultAsync<{
        transactionIntentHash: string;
    }, SdkError>;
};
export {};
