import { LogLevelDesc } from 'loglevel';
type WalletSdkInput = {
    networkId?: number;
    dAppDefinitionAddress: string;
    logLevel?: LogLevelDesc;
};
export declare const Network: {
    readonly Mainnet: 1;
    readonly Stokenet: 2;
    readonly Adapanet: 10;
    readonly Nebunet: 11;
    readonly Gilganet: 32;
    readonly Enkinet: 33;
    readonly Hammunet: 34;
};
export type WalletSdk = ReturnType<typeof WalletSdk>;
export declare const WalletSdk: ({ networkId, dAppDefinitionAddress, logLevel, }: WalletSdkInput) => {
    destroy: () => void;
    __subjects: {
        outgoingMessageSubject: import("rxjs").Subject<{
            interactionId: string;
            items: {
                oneTimeAccounts?: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                } | undefined;
                oneTimePersonaData?: {
                    fields: string[];
                } | undefined;
                discriminator: "unauthorizedRequest";
            } | {
                oneTimeAccounts?: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                } | undefined;
                ongoingAccounts?: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                } | undefined;
                oneTimePersonaData?: {
                    fields: string[];
                } | undefined;
                ongoingPersonaData?: {
                    fields: string[];
                } | undefined;
                auth: {
                    identityAddress: string;
                    discriminator: "usePersona";
                } | {
                    challenge?: string | undefined;
                    discriminator: "login";
                };
                discriminator: "authorizedRequest";
            } | {
                send: {
                    message?: string | undefined;
                    blobs?: string[] | undefined;
                    transactionManifest: string;
                    version: number;
                };
                discriminator: "transaction";
            };
            metadata: {
                networkId: number;
                dAppDefinitionAddress: string;
            };
        }>;
        incomingMessageSubject: import("rxjs").Subject<{
            discriminator: "success";
            interactionId: string;
            items: {
                oneTimeAccounts?: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                } | {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                } | undefined;
                oneTimePersonaData?: {
                    fields: {
                        value: string;
                        field: string;
                    }[];
                } | undefined;
                discriminator: "unauthorizedRequest";
            } | {
                oneTimeAccounts?: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                } | {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                } | undefined;
                ongoingAccounts?: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                } | {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                } | undefined;
                oneTimePersonaData?: {
                    fields: {
                        value: string;
                        field: string;
                    }[];
                } | undefined;
                ongoingPersonaData?: {
                    fields: {
                        value: string;
                        field: string;
                    }[];
                } | undefined;
                auth: {
                    discriminator: "usePersona";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                } | {
                    discriminator: "loginWithoutChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                } | {
                    challenge: string;
                    signature: string;
                    discriminator: "loginWithChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                    publicKey: string;
                };
                discriminator: "authorizedRequest";
            } | {
                send: {
                    transactionIntentHash: string;
                };
                discriminator: "transaction";
            };
        } | {
            message?: string | undefined;
            error: "rejectedByUser" | "wrongNetwork" | "failedToPrepareTransaction" | "failedToCompileTransaction" | "failedToSignTransaction" | "failedToSubmitTransaction" | "failedToPollSubmittedTransaction" | "failedToFindAccountWithEnoughFundsToLockFee" | "submittedTransactionWasDuplicate" | "submittedTransactionHasFailedTransactionStatus" | "submittedTransactionHasRejectedTransactionStatus";
            discriminator: "failure";
            interactionId: string;
        } | {
            eventType: "receivedByExtension";
            interactionId: string;
        }>;
        responseSubject: import("rxjs").Subject<{
            discriminator: "success";
            interactionId: string;
            items: {
                oneTimeAccounts?: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                } | {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                } | undefined;
                oneTimePersonaData?: {
                    fields: {
                        value: string;
                        field: string;
                    }[];
                } | undefined;
                discriminator: "unauthorizedRequest";
            } | {
                oneTimeAccounts?: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                } | {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                } | undefined;
                ongoingAccounts?: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                } | {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                } | undefined;
                oneTimePersonaData?: {
                    fields: {
                        value: string;
                        field: string;
                    }[];
                } | undefined;
                ongoingPersonaData?: {
                    fields: {
                        value: string;
                        field: string;
                    }[];
                } | undefined;
                auth: {
                    discriminator: "usePersona";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                } | {
                    discriminator: "loginWithoutChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                } | {
                    challenge: string;
                    signature: string;
                    discriminator: "loginWithChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                    publicKey: string;
                };
                discriminator: "authorizedRequest";
            } | {
                send: {
                    transactionIntentHash: string;
                };
                discriminator: "transaction";
            };
        } | import("./helpers/error").SdkError>;
        messageLifeCycleEventSubject: import("rxjs").Subject<{
            eventType: "receivedByExtension";
            interactionId: string;
        }>;
        dispatchEventSubject: import("rxjs").Subject<import("./messages/_types").MessageDispatch>;
    };
    request: <Input extends Partial<{
        oneTimeAccountsWithoutProofOfOwnership: {
            quantity?: number | undefined;
            quantifier?: "exactly" | "atLeast" | undefined;
        };
        oneTimeAccountsWithProofOfOwnership: {
            quantity?: number | undefined;
            quantifier?: "exactly" | "atLeast" | undefined;
        };
        ongoingAccountsWithoutProofOfOwnership: {
            quantity: number;
            quantifier: "exactly" | "atLeast";
        };
        ongoingAccountsWithProofOfOwnership: {
            quantity: number;
            quantifier: "exactly" | "atLeast";
        };
        usePersona: {
            identityAddress: string;
        };
        loginWithoutChallenge: {};
        loginWithChallenge: {
            challenge: string;
        };
        login: {};
        oneTimePersonaData: {
            fields: string[];
        };
        ongoingPersonaData: {
            fields: string[];
        };
    }>, Output extends keyof Input extends keyof {
        oneTimeAccountsWithoutProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
            method: {
                input: {
                    quantity?: number | undefined;
                    quantifier?: "exactly" | "atLeast" | undefined;
                };
                output: {
                    oneTimeAccounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
        };
        oneTimeAccountsWithProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
            method: {
                input: {
                    quantity?: number | undefined;
                    quantifier?: "exactly" | "atLeast" | undefined;
                };
                output: {
                    oneTimeAccounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
        };
        ongoingAccountsWithoutProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
            method: {
                input: {
                    quantity: number;
                    quantifier: "exactly" | "atLeast";
                };
                output: {
                    ongoingAccounts: {
                        address: string;
                        label: string;
                        appearanceId: number;
                    }[];
                };
            };
        };
        ongoingAccountsWithProofOfOwnership: {
            wallet: {
                request: {
                    requiresProofOfOwnership: boolean;
                    numberOfAccounts: {
                        quantifier: "exactly" | "atLeast";
                        quantity: number;
                    };
                };
                response: {
                    accounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
            method: {
                input: {
                    quantity: number;
                    quantifier: "exactly" | "atLeast";
                };
                output: {
                    ongoingAccounts: {
                        account: {
                            address: string;
                            label: string;
                            appearanceId: number;
                        };
                        challenge: string;
                        signature: string;
                    }[];
                };
            };
        };
        usePersona: import("./IO/request-items").UsePersona;
        loginWithoutChallenge: {
            wallet: {
                request: {
                    challenge?: string | undefined;
                    discriminator: "login";
                };
                response: {
                    discriminator: "loginWithoutChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
            method: {
                input: {};
                output: {
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
        };
        loginWithChallenge: {
            wallet: {
                request: {
                    challenge?: string | undefined;
                    discriminator: "login";
                };
                response: {
                    challenge: string;
                    signature: string;
                    discriminator: "loginWithChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                    publicKey: string;
                };
            };
            method: {
                output: {
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                    signedChallenge: {
                        challenge: string;
                        publicKey: string;
                        signature: string;
                    };
                };
                input: {
                    challenge: string;
                };
            };
        };
        login: {
            wallet: {
                request: {
                    challenge?: string | undefined;
                    discriminator: "login";
                };
                response: {
                    discriminator: "loginWithoutChallenge";
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
            method: {
                input: {};
                output: {
                    persona: {
                        label: string;
                        identityAddress: string;
                    };
                };
            };
        };
        oneTimePersonaData: import("./IO/request-items").OneTimePersonaData;
        ongoingPersonaData: import("./IO/request-items").OngoingPersonaData;
    } ? { [Key in keyof Input]: (x: {
        oneTimePersonaData: {
            oneTimePersonaData: {
                value: string;
                field: string;
            }[];
        };
        ongoingPersonaData: {
            ongoingPersonaData: {
                value: string;
                field: string;
            }[];
        };
        usePersona: {
            persona: {
                label: string;
                identityAddress: string;
            };
        };
        login: {
            persona: {
                label: string;
                identityAddress: string;
            };
        };
        loginWithoutChallenge: {
            persona: {
                label: string;
                identityAddress: string;
            };
        };
        loginWithChallenge: {
            persona: {
                label: string;
                identityAddress: string;
            };
            signedChallenge: {
                challenge: string;
                publicKey: string;
                signature: string;
            };
        };
        oneTimeAccountsWithProofOfOwnership: {
            oneTimeAccounts: {
                account: {
                    address: string;
                    label: string;
                    appearanceId: number;
                };
                challenge: string;
                signature: string;
            }[];
        };
        oneTimeAccountsWithoutProofOfOwnership: {
            oneTimeAccounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
        };
        ongoingAccountsWithProofOfOwnership: {
            ongoingAccounts: {
                account: {
                    address: string;
                    label: string;
                    appearanceId: number;
                };
                challenge: string;
                signature: string;
            }[];
        };
        ongoingAccountsWithoutProofOfOwnership: {
            ongoingAccounts: {
                address: string;
                label: string;
                appearanceId: number;
            }[];
        };
    }[Key]) => void; }[keyof Input] extends (x: infer T) => void ? T : never : never>(input: Input, callbackFns?: Partial<import("./messages/events/_types").CallbackFns>) => import("neverthrow").ResultAsync<Output, import("./helpers/error").SdkError>;
    sendTransaction: (input: {
        transactionManifest: string;
        version: number;
        blobs?: string[] | undefined;
        message?: string | undefined;
    }, callbackFns?: Partial<import("./messages/events/_types").CallbackFns>) => import("neverthrow").ResultAsync<{
        transactionIntentHash: string;
    }, import("./helpers/error").SdkError>;
};
export { ManifestBuilder } from './manifest-builder';
export * from './scrypto-value';
export { requestBuilder } from './request-builder';
export * from './IO/request-items';
export * from './IO/schemas';
export * from './helpers/error';
